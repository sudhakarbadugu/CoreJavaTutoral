-------------------------------------------------------------
03-07-2018 Tuesday
-------------------------------------------------------------
1. Install java
	
2. Verify java installation
	1. By manual process
		Go c drive -> program files -> java

		Program files --> 64 bit os
		Program files(x86) --> 32bit os
	
or
	open cmd prompt
	cmd -> type java and enter
	
	2. Verify java version by typing below command in cmd
		java -version 
			YOu should see the below screen.	
			java version "1.8.0_162"
			Java(TM) SE Runtime Environment (build 1.8.0_162-b12)
			Java HotSpot(TM) 64-Bit Server VM (build 25.162-b12, mixed mode)

Opening cmd promps
	1. win + type cmd 
	2. win+R and type cmd
	3. shift + right click -> Open powershell window option here.
-------------------------------------------------------------
1. All files must end with .java extension.
-------------------------------------------------------------04-07-2018	Wednesday
-------------------------------------------------------------What is Java?

What are java editons?
--------------------------------
What is Java?
Java:
	- Java is high level, object oriented programming language. 
	- It is an API and it is an Open source.
  program:
	- Set of line which performs a task.	E.g Adding 2 numbers
	
  Object:
	- Any things which is existing in the real world. E.g: A dog
		- properties: which it has. 	E.g: A dog has 4 legs, A man has 2 legs
		- Actions:	which it can performs	E.g: it can bow bow.
	
  API: Application Programming Interface
	- A set of guide lines with classes and interfaces

  Open source:
	- Freely available. 

	
What are java editons?
Types:
1. JSE: Java Standard Edison
2. J2EE: Java Enterprise Edition
3. J2ME: Java Micro Edition
4. JavaFx


1. Java SE: Java Standard Edison
	- Basics programming
	- standalone appliations: It will run only on a machine.
	- we can't write web applicatons.
	
2. J2EE: Java Enterprise Edition
	- To write web appliations.
		- which runs on the internet
			E.g: internet banking, whatapp web, facebook
	
3. J2ME: Java Micro Edition
	- Create mobiles applications.
	
4. JavaFx
	- To create the internet applications.
-------------------------------------------------------------05-07-2018 Thursday
-------------------------------------------------------------What are the java versions and History?
James Gosling , Mike Sheridan, and Patrick Naughton started java language project in 1991.
- first java named as Greentalk.
- then they renamed as Oak. Oak - strength. Other company registered with oak technoloy so they changed to Java.
- They named as Java.
- Java is only a name and abbrevation.
- Sun micro systems developed java technoloy.
- JDK 1.0 released in(January 23, 1996).

Java Version History
There are many java versions that has been released. Current stable release of Java is Java SE 10.

JDK Alpha and Beta (1995)
JDK 1.0 (23rd Jan, 1996)
JDK 1.1 (19th Feb, 1997)
J2SE 1.2 (8th Dec, 1998)
J2SE 1.3 (8th May, 2000)
J2SE 1.4 (6th Feb, 2002)
J2SE 5.0 (30th Sep, 2004)
Java SE 6 (11th Dec, 2006)
Java SE 7 (28th July, 2011)
Java SE 8 (18th March, 2014)
Java
 SE 9 (21st Sep, 2017)
Java SE 10 (20th March, 2018)

What we can do with Java?
- We can create web applications.
- we can create games.
- we create android apps.
- we can use java in televisions and setup boxes
- we can create mobile applications.

What are the features?
-- Once learn the basic programs
-------------------------------------------------------------
Basics
--------------------------------------------------------------
- Simple java program

Reserved/keyword words: 51
	- It has some meaning to java compiler. 
	- All reserved words in small letters only.
1. class - to declare a class.
2. public - 
3. static - 
4. void - It returns nothing. 

5. byte - 1byte -127 to 127
6. short	- 2bytes 
7. int 		-  4 bytes
8. long		- 8 bytes
9. float	- 4 bytes
10. double	- 8 bytes
11. char 	- 2 bytes
12. boolean - true/false

13. true
14. false 

15. if
16. else 
17. switch
18. case
19. break

20. extends
21. implements
22. this
22. super


how to compile
	javac filename.java
	E.g: javac welcome.java

How to run a java program
	Syntax: java classname
	E.g: java A	
	
task:
1. Write a program. HelloWorld.
	print out: Hello Murali, welcome to chennai.
	
-----------------------------------------
0-07-2018
-----------------------------------------
How to write a java program?
- A file with .java extension called a java file.

How to compile a java program?
- javac file name with extension
	E.G: javac Addition.java
	
How to run a java program?
	Syntax: java classname
	java Addition
	
What is platform independant?
JRE, JDK and JVM?
- Same program will run in linux, windows without recompiling it. It runs on anywhere.

Tasks:
- Write a-z java files and compile them?

-------------------------------------------------------
07-7-2018 Saturday
-------------------------------------------------------
Building blocks:
1. Class
2. variables
	1. instance
	2. static
	3. local
	
3. methods
	1. instace 
	2. static
4. constructors.
	1. default
	2. parameter
	
5. blocks.
	1. instance
	2. static
	
how to declare a java class?
1. Class:
	- using class keyword we can declare a class.
	Syntax: 
	class Addition {
	}

	- All building blocks (variables, blocks, constructors and methods) should be inside a class. if we are declaring out side, compiler will give you an error. 
		Welcome.java:5: error: class, interface, or enum expected
		int i = 10;
		^
		1 error

2. variables:

------------------------------------------------------
09-07-2018 Monday
------------------------------------------------------
Identifiers: A name of class or variable or a method name called identifier.
	class Test {
	}
	
	eg: Here Test is identifier. It is a name of a class.
	
- A name of variable.
	int salary = 20000;
	-------------------
	int - datatype
	salary - variable name - identifier
	200000 - value/literal.
	
- A name of method.
	public static void main(String args[]){}
	--------
	main - name of a method.
	args - variable - identifier

Identifier naming rules:
class:
	- It should start capital letter and camel case.
		MethodExample

Method/variable:
	- It should start small letter and camel case
		int length;
		methodOne(){}
		int a[]; a.length


Identifiers Naming rules:-
1. Only a-z, 0-9,_ and $ allowed in identifiers.
	int age = 20;
	int #age = 30;	//invalid
	int age$ = 40;	
	int man age = 50; //invalid: Space should not be there in identifier
				//Error: 
	
2. Identifier name should not start with numbers.
	int sno1 = 20;
	int sno2 = 30;
	int 1sno = 10;	//invalid
	int man_age = 20;
	int $age = 60;
	int class = 20; //invalid
	
3. should not use reserved words.
4. Name should not contain any white spaces
	int a b = 30; //invalid
-------------------------------------------------------------
Data types:
Pre defined data type or primitive data types.
1. Numeric/numbers
	1.1 Real numbers (1)
		1. byte
		2. short
		3. int
		4. long
	1.2 Fraction numers (0.2323)
		1. float
		2. double
2. boolean type
	1. boolean
3. char tye
	1. char

Data type:
which type of data it is.
	byte a = 10;`//valid
	byte b = false;	//invalid
		VariableExample.java:6: error: incompatible types: boolean cannot be converted to byte
                byte b = false;
				
1. byte:
	Range: -128 to 127
	memory: 1 byte = 8 bits
	E.g: byte b = 120; //valid
		 byte c = 140; //invalid: possible loss of precision
		 byte d = -130; //invalid
		 
2. short
	range -32768 to 32767
	memory: 2 bytes = 2power16
		E.g: short s = 200;
			short s1 = 32769; //invalid possible loss of precision
			
3. int 
	range: 2147483647
	memory: 4 bytes = 2power32
		int i = 1;
		int i2 = 2000;
		int i3 = 2147493847;	//invalid
		int i4 = b + s;	//valid.

4. long	
	range: -9,223,372,036,854,775,808  to 9,223,372,036,854,775,807
	memory: 8 bytes = 2power64
	long l = i + i2;
	byte b = i+ i2;	//invalid
	
	
5. float
	4 bytes = 32 bits.
	up to 7 points it can store.
	float f  = 23.011232323232323234545f;
	float f1 = 220.2; //invalid, decimal values always referred as double value.
	
	
6. double 
	8 bytes = 64 bits	
	up to 14 points it can store.
	double d = 12.0;	
	double c = 12;
	double d1 = 10.0d;
	double d1 = 10.0f;
	double d3 = false;	//invalid
	
------------------------------------------------------------
byte --> short --> int --> long --> float --> double       |
-------------------------------------------------------------
	long l = 222222;
	float f = l;	//valid
	
	double l = 222222;
	float f = l;	//in valid
	
--------------------
7. char: 
	Range: 65636
	2bytes : 2power16
	char i = 'm';
	char b = 'Z';
	char c = 'A' or 65;
	char d = 100; //valid
	char e = 666666; //invalid

8. boolean
	boolean b = true;
	boolean c = false;

--------------------------------------------------------------
String:
It is a class.
	String name = "Sudhakar";
	String s = 100;	//invalid 	CE: incompatible types
	String s2 = "200";
	
Tasks:
	take a class and print the values -> PrintValues
	
		- name
		- age
		- dob
		- father name
		- village name 
		- income
		
2. write programs for sum, substraction, div and mul for int, long and double.
-------------------------------------------------------------
Control statements:
if
if else
else if
switch

1. if 
	If we have only one condition, then should go for if case.
	E.g: Print whether given number is even
		if(xx){
		}
xx - only boolean type or boolean result
	if(i % 2 == 0){}	//
	
- brackets optional
- If no brackets are there, then only one line is in if block
- always boolean type is required 
	- boolean expression
	 1 == 2 ==> false
	 1 == 1 ==> true
	 1 != 1 => false
	 int i = 10 ==> ce	
---------------------------------------------------------------
class IfExample {
	public static void main(String args[]){
		int i = 10;
		boolean b = false;
		
		if(b){
			System.out.println("Boolean value is true");
		}	
		
		if( i == 10){
			System.out.println("I value is "+ i);
		}
		
		if(i % 2 == 0){
			System.out.println("Even number");
		}
		
		if(b)
		System.out.println("First line");
		
		System.out.println("second line");	
	}
}

---------------------------------------------------------------
2. if else
	If we want show something when if condition is failed, means we have 2 condtions. 
		if(age > 18){
			SOP("You are elegible for vote");
		}
		else{
			//you are not elegible
		}

- If if condition is failed then only else will be execued.
		
3. else if
	If we have more than 2 condions , then we should go for else if.
		if(condition){
		}
		else if(condions){
		
		}
		else if(condions){
		
		}else {	//optional
		
		}
-------------------------------------------------------------
class IfExample {
	public static void main(String args[]){
		int marks = 25;
		
		if(marks >= 60 && marks < 70){
			System.out.println("first class");
		}		
		else if(marks >= 70 && marks < 80 ){
			System.out.println("Distinction");
		}
		else if(marks >= 80 ){
			System.out.println("Topper");
		}
		else if(marks < 35){
			System.out.println("Failed");
		}		
		else {
			System.out.println(" Just Pass");
		}
	
		System.out.println("End");
	}
}

//should not write like this.
//because it executes all if statements in the program.
class IfExample {
	public static void main(String args[]){
		int marks = 25;
		
		if(marks >= 60 && marks < 70){
			System.out.println("first class");
		}
		
		if(marks >= 70 && marks < 80 ){
			System.out.println("Distinction");
		}
		
		if(marks >= 80 ){
			System.out.println("Topper");
		}
		
		if(marks < 35){
			System.out.println("Failed");
		}		
		else {
			System.out.println(" Just Pass");
		}
	
		System.out.println("End");
	}
}

-------------------------------------------------------------
3. switch

- If we have more than 2 condions , then we should go for switch.
	
syntax:
	switch(xx){	//
	}
xx - should be byte, short, int, char, String, boolean, enum.
		int i = 10;
		switch(i){
		}
		
- Not allowed in case arguments - float, long, double.

case: each condition is called as case.


switch(xx){
	case 1: {
	}
	
	case 2: {
	}
	default: {
	}
}
points:
- syntax: 
	switch(xx){
		case 1: {
		}
		
		case 2: {
		}
		default: {
		}
	}
1. xx - byte, short, int , String, enum and boolean
2. cases are optional. even default also optional.
3. case can be in any order. e.g: case 3: case 2: default
4. case label duplicates are not allowed.
5. default case also optional.
6. arguments (xx) and case lables (1, 2) must be same type. 
7. break - to stop the next case execution. break optional.
8. Between 2 cases nothing is allowed. we should not write even SOP also.
9. break should be used only in switch.

Assignment
write below program:
String name ="Sudha";

sudha: 27
mural: 21
venky 24
ashok: 27
prasad: 21

switch(name){
}

-------------------------------------------------------------------------------------------
class SwitchDemo {
	
	static public void main(String[] a){
		
		int age = 6;
		String s = "1";
		
		switch(age){
			case 1: {
				System.out.println("Baby");
				break;
			}
			
			case 2: {
				System.out.println("Pre class");
				break;
			}
			
			case 3: {
				System.out.println("LKG");
				break;
			}
			
			case 5: {
				System.out.println("UKG");
				break;
			}
			// System.out.println("middle");
			case 6: {
				int ab = 20;
				System.out.println("First");
				
			System.out.println("middle");
			
				break;
			}
						
			default: {
				System.out.println("Big man");
			}
		}
	}
}
---------------------------------------------------
26-7-18 Iterative statements or loops
-------------------------------
1. for
2. while
3. do while

Syntax:
	for(i;c;id){
		body
	}
	
	i -- initilization:
		int i = 1;
		
	c -- condition  - always true/false
		i < 10 --> true
		
	id -- increment/decrement
		i++	/ ++i / i = i+1
		i--	/ --i

1. init - optional
2. condition - optional -- by default value is true
3. incr/decrement - optional

flow:
	for(1;2 ;4) {
		3
	}
	Sop("compeleted");
	
	
	1 - init 
	2 - conditon
	3 - body
	4 - increment

- for loop open and close {} brackets are optional.
- if for is true always and if there are any statements below the while loop then compile time error will show as unreachable statement.
	eg.
		for(; true ;){
		}
		System.out.println("End");
------------------------------------------------------------
class PrintNumbers {
	public static void main(String[] args){

		for(int i=50; i> 0; i--){
			
			if(i % 2 == 0){
				System.out.println("Even number" + i);
			}
		}		
	}
}

class PrintNumbers {
	public static void main(String[] args){

		for(int i=0; i< 50; i++){
			
			if(i % 2 == 0){
				System.out.println("Even number" + i);
			}
		}		
	}
}
-----------------------------------------
27-07-18 while
-----------------------------------------
- When we don't know the how many iteration we want then we should go for while loop.
Syntax:
	while(conidtion){
		//body
	}
	
- condition: always boolean value/expression.
- if condition is true, while body will be executed.
- while - condition is mandatory.
- while will not execute if condition is wrong.

- if while is true always and if there are any statements below the while loop then compile time error will show as unreachable statement.
	eg.
		while(true){
		}
		System.out.println("End");
-------------------------------------------------------
class WhileExample {
	static public void main(String[] args){

		
		int j = 90;
		while(j > 100){
			if(j % 2 == 0){
				System.out.println(j);
			}		
			
			j = j -1;
		}
		
	}
}
---------------------------------------------------------------
do while:
---------
syntax;
	do {
		//Body
	}while(condition);
	
- do will execute atleast once even if condition wrong.
- break - we can use in loops also.
----------------------------------------------------------
class DoWhileExample {
	static public void main(String[] args){
		int i = 100;
		do {
			if(i % 2 == 0)
			System.out.println(i);
			i = i -1;
		}while( i > 50);
	}
}
--------------------------------------------
29-07-18	Operators
--------------------------------------------
1. Unary Operator,
2. Arithmetic Operator,
3. Shift Operator,
4. Relational Operator,
5. Bitwise Operator,
6. Logical Operator,
7. Ternary Operator and
8. Assignment Operator.

Unary Operator:
	1. pre increment
	2. pre decrement
	3. post increment
	4. post decrement
	5. ~
	6. !

1. pre increment: First increment will happen
	++x;
	 int x = 10;
	 
	 ++x; //11
	 
2. pre decrement: First decrement will happen
	--x;
	int y = 20;
	--y; //19

3. post increment: It will not increment in the current line, incrment will happen in second.
	 int x = 10;
	 Sop(x++); 10
	 Sop(x); 11
	 
	 
4. pre decrement: It will not decrement in the current line, decrement will happen in second.
	int y = 10;
	 Sop(y--); 10
	 Sop(y); 9
	 
5. not operator (!)
- It applialbe for only boolean type.
	Eg. boolean b = false;
	boolean c = !b;	//true
	int i = 10;
	int j = !i; //ce: \UnaryOperatorsDemo.java:21: error: bad operand type int for unary operator '!'
                System.out.println(!c);

6. ~ tilde operator:
- Only number types
	E.g: int y = 20;
		int z = ~y; //-21
		int x = ~z; //20
		boolean a = ~true; ce: .\UnaryOperatorsDemo.java:21: error: bad operand type boolean for unary operator '~'
                System.out.println(~value);
				

2.1 Arithmetic operators
	int a = 10;
	int b = 3;
	+	= a + b; 13
	-   = a -b; 7
	*   = a * b; 30
	/	= a/b; 3
	%	= a%b; 1
	
3. Relational operators
	int a = 20;
	int b = 30;
	<	==> a < b == true
	>	=> a> b	==false
	<=	=> a <=b == true
	>=	=> a >= b = false 
	==	=> a == b == false 
	!=	=> a != b == true
	
4. Logical operatos:
	Double AND &&
	doble OR || 
	
	&& -> if both conditions are true then only it will be true.
		- If first condition is true then only second condition will be executed.
		
		int x = 30;
		
		if( x > 20 && x < 30){	//total result false. 1st condition is true but second condition is false so result is false.
			System.out.println("more than 20 and less then 30");
		}
		
	|| -> if both conditions are false then only it will be false, in all other scenarios it will be true.
		- If first condition is true then second condion will not be execued.
		int x = 25;
		if( x > 20 || x < 30){
			System.out.println("or operator more than 20 or less then 30");
		}
		
Ternary operator;
	?:
E.g:
	int y = 1;
	
	int age = y <0 ? 0 : y;
	System.out.println(age);
	
Bitwise operators:
&	- true & true = true 
	- true & false = false
	- false & false = false
	
|	- true | true = true 
	- true | false = true
	- false | false = false
	
^ 
- this is applicable only for numbers
-----------------------------------------------------------
30-7-18 Arrays
-----------------------------------------------------------
int r1 = 1;
int r2 = 2;
int r3 = 3;
int r4 = 4;
.
.
int r100 = 100;

Array:
- To store group of homogenious (same type) values.
- Size/length is fixed.
- Array is index based. the index starts 0 and last index is size-1.
- If we are trying to get the value from array where index is greater than size, then ArrayIndexOutOfBoundsexception will occur.

	syntax: array declaration:
	int[] rollNos = new int[size];
size -- always integer
Steps:
1. array declaration.
	int[] rollnos = new int[30];

2. array initilization
	rollnos[0] = 100;
	rollnos[29] = 130;
	
3. Display the array data
	for(int i = 0; i < rollnos.length ; i++){
		Sop(rollnos[i])
	}

--------------------
int a;
a = 20;

- Array can initilized in 2 lines as give below.
int[] a;

a = new int[10];
a[0] = 1;


- Array declaration and initilization in one line
	int[] numbers = {1,5,7,5,5,5,6};
--------------------
foreach loop:
--------------------

for(datatype identifier: arrayName){
  Sop(identifier);
}

----------------------------------------------|
 OOPS 01-08-2018
----------------------------------------------|
methods:
-------
- A group of statements which does a task.
- Should be declared directly inside a class but not inside the another method.
Uses:
- To avoid the code duplicates.
- To reuse the code.
- we can reduce no of lines code using method.
- To separate functionlity
	E.g: add - add method functionlity
	swap - swap method functionlity.


public void m1(int a){
}

public - access specfier
void - return type - returns nothing.
m1 - method name
int - parameter type
a - parameter name. 
--------------------------------
methods are 2 types:
1. Instance method.
2. static method.

1. Instance method:
 - A method which is not declared with static keyword called instance method.
 - To call the instance method, we need to create an object.

	public void m1(){}

	Steps:
	1. Declare a method in a class.
		class MethodExample {
		
			public void m1(){
				Sop("m1");
			}
		}
	2. Calling m1 method.
		1. Create a object for that class where method exist.
			MethodExample object = new MethodExample();
		2. Call the method using object.
			object.m1();
		
2. Static method:
	A method which is declared with static keyword called static method.
 - For static methods, we no need to create object. using class name we call the static methods.
 
	public static void m1(){}
	
Steps:-
	1. Declare a static method in a class.
		public static void m2(){
			Sop("m2 static");
		}
	2. Calling m1 method.
		Using Class.methodname, we can call static method.
		E.g 
			MethodExample.m2();

	
Accessing methods:
-----------------
Can we call instace method from static method?
ans: yes, we can call using object. here m2 is instance method. m1 is static method. 
m1 method is calling m2 method.

	public void m2(){
		System.out.println("m2");
	}
	
	public static void m1(){
		System.out.println("m1");
		
		MethodCallingExample mce = new MethodCallingExample();
		mce.m2();
	}
	

Can we access static method from static method?
yes, we can call using methodname directly or using Classname.methodname. here m1 and m3 are static methods. m3 is calling m1 method.

	public static void m1(){
		System.out.println("m1");
	}
		
	public static void m3(){
		System.out.println("m3");
		m1();
	}
	
Can we call static method from instance method?
yes, we call call using methodname or using Class.methodname. Here m2 is instance mehtod, m4 is static method. m2 is calling m4 method using classname.methodname.

	public void m2(){
		System.out.println("m2");
		MethodCallingExample.m4();
	}
	
	public static void m4(){
		System.out.println("m4");
	}
	
Can we access instace method from instance method?
yes, we can call. here m2, m5 are instances methods. m2 method is calling m5(). 

	public void m2(){
		System.out.println("m2");
		m5();
	}

	public void m5(){
		System.out.println("m5");
	}
-----------------------------------------	
method type | instance method	|static 		|
------------|-------------------|-------		|
instance    | yes,eg: m1()      |yes, e.g, m2()	|
------------|-------------------|-------		|
static 		 no, using object   |yes. eg:m2()	|
			  we can call. 
			  eg: obj.m1()      |    			|
------------|-----------|-------|--------------	|
	
Note:
1. If a method is calling itself then StackOverflowError will come.
	public void m1(){
		mce.m1();
	}
	
2. If 2 methods are calling each other, then StackOverflowError will come.
	p v m1(){
		m2();
	}
	
	p v m2(){
		m1();
	}
-----------------------------------------------
03-08-2018 method params
-----------------------------------------------
1. Method params.
	Varibles which are declared inside method brackets called method parameter/variables.
	E.g: 
		public void add(int c, int a){
		}
	Here: c & a are called method parameters.
	
- While declaration of method parameters, should not initilize the value for method parameters.
	E.g: public void add(int i = 20, int c) - X 
		 public void add(int i = 20, int c = 0) - X 
		 public void add(int i, int c) - ok 

2. While calling this method, we need to pass only specified type values.
	E.g:
	m1(int a, int b){}
	m1.add(10, 20); - Ok
	
	m1.add(10.0, true); - X 
	- CE: expected int,int but found double and boolean.
	
	m1.add(int a, int b); - X 
	- we should not declare variables while calling.
	
	int a = 0;
	int b = 33;
	m1.add(a, b); -- ok
	m1.add(0, 30); -- ok
	m1.sub(a, b); -- ok
	
3. Method parameter - scope
	We can access only with in the declared method.
		here: 
		public void m2(int a){
			System.out.println(a);			
		}
		
		public void m3(){
			System.out.println(a); -X //a is not declard in thi method. it is avaialbe only in m2 method.			
		}
--------------------------------------------------
Method return types:
---------------------------
public int m1(int a) {
	return 0;
}
public - access specifier/modifier
int - return type - date type is int
	- any data type is possible here.
	eg. int 
		float
		boolean
		void
		MethoOne
		
1. Each method must have a return type before the method name.
	public void m1(){}
	Here, void is the return type.
	
	public static m1(){} X//CE return type is missing.
	
2. void means, it returns nothing. so no return statment is not required in the method.
	Eg.
		public void m1(){};	Ok
		public void m1(){ return 1}; X c.e: when method return type is void we should not return any thing/value.

3. If return type is otherthan void, like int,float and all other datatypes, then must return the value.
		public void m1(){}	Ok
		public int m2(){return 1;}	Ok
		public int m3(){}	X //CE: return type is missing.
		public int m4(){return true;}	X //CE: return type is wrong.
		public int m4(){return int a;}	X //CE: return type is wrong. we should not declare
		public int m4(){return a;}	Ok 
		
4. If any method return type is otherthan void, then while calling we may store the value. storing the value is not always required.
	class A {
	
		p s v m(String[] args){
			A a = new A()
			int c = a.m2(); // when we required
			a.m2(); // when we don't want the value.
			
			//int  a =a.m1(); X 
			//int a = MethodReturnTypeExample.m1(); ce:MethodReturnTypeExample.java:10: error: incompatible types: void cannot be converted to int
			
			a.m1(); Ok
		}
		p v m1(){
			
		}
		
		p int m2(){
			return 1;
		}
	}

5. If return type is void, we should not store that to a variable in caller method.
		p v m2(){};
		int a = m2(); X//CE error: incompatible types: void cannot be converted to int
		
6. return statement should be the last line of a method. Otherwise we will get compile time error as unreachable statement.
	p int m1(){
		return 0;
		int a = 20;	- X; unreachable statement
	}
	
7. If method return type is a class name, then we should return that class object in that method.
	public static MethodReturnTypeDemo getObject(){
		MethodReturnTypeDemo m = new MethodReturnTypeDemo();
		return m;
	}

------------------------------------------------------------
Variables:
which holds/stores some value.
int i = 20;

Here:
int - datatype
a - identifier - variable name
= - operator
30 - value/literal

3 types:
--------
1. instance variables
2. static variables
3. local variables

------------------------
1. Instance variables
------------------------
 A variable which declared in side a class but outside of the methods.
 e.g: Here x is instance variable.
	class A {
		int x = 20;
		static int y = 35;
		
		p v m1(){
			int z = 30;
			System.out.println(x);
		}
		
		p s v m2(){
			//System.out.println(x); 
			//C.E: error: non-static variable x cannot be referenced from a static context
            
			A a = new A();
			System.out.println(a.x);
		}
	}
- If more than 2 or more methods uses same variable then we can declared that variable as instance variable.

- instance variables can be directly used in only instance methods.
- instance variables can't directly used in static methods.

- instance varibles are called properties.
- which properteis are specific to each object, those properties should be decalared as instance variables. e.g age, name, fatherName.

- For each object a separate copy of instance variables will be there.

- instance variables can be accessed through the object in static methods.
	p s v m2(){
		A a = new A();
		sop(a.x);
	}

- For instance varibles jvm will provide default values.
	default values for instance variable:
	primitive data types:-
		byte, char, short, int, long ==> 0
		boolean => false 
		float, double => 0.0

	String and other classes => null
---------------------------------------------	
2. Static variable
---------------------------------------------
  A variable which declared in side a class but outside of the methods which declared with static keyword.

 e.g: Here y is static variable.
	class A {
		int x = 20;
		static int y = 35;
		
		p v m1(){
			int z = 30;
		}
	}
- If more than 2 or more methods uses same variable then we can declare that variable as static variable.

- static variables can be directly used instance methods as well as static methods.
 	
- which are common to all objects, those properties should be decalared as static variables. e.g collegeName, villageName.

- For all objects only one copy of static variables will be there.
If we chage the static variable using any object, it will change to all other objects.
	s1.collegeName = "ajlj";
	sop(s2.collegeName) //it will print the above value.

- For static varibles also jvm will provide default values.
	default values for instance variable:
	primitive data types:
	byte, short, int, long ==> 0
	boolean => false 
	float, double => 0.0

	String and other classes => null

--------------------
3. Local variable:
--------------------
 A variable which declared inside a method, or method parameters called local variable.
 
 e.g: Here a and z are local variables.
	class A {
		int x = 20;	//instance
		static int y = 35; //static
		
		p v m1(int a){
			int z = 30;
		}
		
		p v m2(){
			Sop(z); //X:CE: can't find symbol z
		}
	}
- We can't access the local variables of a method in another method.
- For local variables default value shall not provide by jvm.
	p v m1(){
		int l;
		sop(l); //CE: can't initilize, jvn not providing the default value.
	}
-----------------------------------------------------  |	
variable type | instance method	  |static method         |
--------------|-------------------|--------------------|
instance var  | yes,eg: sop(a)    |no, e.g, sop(obj.a);
------------- |-------------------|--------------------|
static 	var   | yes,eg: sop(a)    |yes,eg: sop(a)
------------- |------------------|--------------------|

26-09-2018
- Getter:
- For each instance variable, we should have getter.
- getter method return type is as same as instance variable data type.
- getter should not take any method parameter.
- instance variable should be declared as private.
- getter method should return instance variable.
- getter method access specifier should be public.

	class Person{
		private String name;
		
		public String getName(){
			return name;
		}
	}

	
- Setter:
- For each instance variable, we should have setter method.
- setter method access specifier should be public.
- setter method return type is void. It should not return any value.
- setter should take one parameter and parameter data type is same as instance variable.
- instance variable should be declared as private.
- setter method should not return any value.
- When method parameter name and property name are same, then we should specify the instance variable name with this keyword. Otherwise value will not set to instance variale.

	class Person{
		private String name;
		
		public void setName(String name){
			this.name = name;
		}
	}

	
27-09-18
Constructor:
- Constructor is like a method. 
- Constructor name should be as same as class name.
- constructor should not have any return type.
- When ever we create an object for a class then immediately constructor will be executed.
- A constructor which is not having any parameter called default constructor.
	class Movie {
		public Movie(){	//default
		}
		
		public Movie(int a){	//parameterized
		}
	}
- types:
	1. default constructor:
		A constructor which does not have any parameter
		If no constructors are avaialbe in our class, then jvm will provide the default constructor.
		
			public Movie(){}
			
	2. parameterized constructor:
		A constructor which has parameters.
			public Movie(int a){}
			
			
- If we add return type to constructor, then it will be considered as a method. It is no more a constructor.
- if developer is not writing any constructor in a class then jvm will provider default constructor.
- In one class we can have more than one constructor also.
- From construcor we can call instance methods as well static methods.
- In construcor we can use 
instance variables as well static variables.


what is the use of constructor?
- To perform the initilization for the instance variables.
- If we want to call any method which has to be executed only once for object, we should call from construcor.

How many times constructor will be executed?
For each object 1 time constructor will be executed. if we create 10 objects, 10 times will be execued.

If we set value from construcor as well as from settter, which will take highest precedense?
	- Setter method value will be availabe, because it is overriding the constructor value.
	eg
		Movie m = new Movie("Sudhakar", "Suma");
		
		m.setHero("Murali");
		m.setHeroin("Kajal");
		
		op: Murali, Kajal
	
1-10-2018
- The parameter order is very important.
E.g: Movie(1, 1);
	Error: incompatible types.
	
- We can have any number of constructors in our class. But we can't have 2 constructors with same type order and same number of parameters.
	Eg : 1 - Compile time error, construcor already defined.
		
		public Movie(String fgdfgdgsdfg, String heroin){
		}
		
		public Movie(String a, String b){
		public Movie(String a, String b){
		}
	
	Eg : 2 Valid. It works
		public Movie(String fgdfgdgsdfg, String heroin){
		}
		
		public Movie(String a, int b){
		}
	
	Eg : 3 Valid. It works
		public Movie(int a, String heroin){
		}
		
		public Movie(String a, int b){
		}
		
	Eg : 4 Compile time error:Constructor already defined.
		public Movie(){
		}
		
		public Movie(){
		}
	
- One construcor can call another construcor using this(). But it should be first line in the construcor.
	E.g:1 Works fine.
		public Movie(){
			this(1);
		}
		
		public Movie(int a){
		
		}
		
	E.g:2 Compile time error: this() should first line of a construcor.
		public Movie(){
			System.out.print("Defalut");
			this(1);	//CE
		}
		
		public Movie(int a){
		
		}
	
- Recursive construcor calling is not possible in java
	E.g: Compile time error: Recursive calling of constructor.
		public Movie(){
			this(1);	
		}
		
		public Movie(int a){
			this();
		}

- Constructor overloading: 2 constructors having different  type of parameters or different number of parameter called construcor overloading.
	
	Eg : 2 Valid. It works
		public Movie(String fgdfgdgsdfg, String heroin){
		}
		
		public Movie(String a, int b){
		}
		
		public Movie(String a, int b, int c){
		}
-------------------------- Constructor example --------------------------------------------------
		class Movie {
			private String hero;
			private String heroin;
			private int shootingDays;
				
			private static int movieCount;
			
			public Movie(){
				this("b", "a");
			}
			
			public Movie(String a, String heroin){
				System.out.println("Movie constructor");
				hero = a;
				this.heroin = heroin;
				
				//we can instance as well static.
				this.init();
			}
			
			public String getHero(){
				return hero;
			}
			public void setHero(String hero){
				this.hero = hero;
			}
			
			public String getHeroin(){
				return heroin;
			}
			
			public void setHeroin(String heroin){
				this.heroin = heroin;
			}
			
			public static void main(String args[]){
				Movie m = new Movie("Sudhakar", "Suma");
				
				m.setHero("Murali");
				m.setHeroin("Kajal");
				
				Movie m1 = new Movie("Sudhakar2", "Suma3");	
				
				Movie m2 = new Movie("Sudhakar1", "Suma2");
				
				Movie m3 = new Movie("Sudhakar1", "Suma2");
				
				System.out.println(m.toString());		
				System.out.println(m1.toString());		
				System.out.println(m2.toString());
			}
			
			public void init(){
				System.out.println("taking rest");
			}
			
			public String toString(){
				return this.hero + " "+ this.heroin + " "+ this.shootingDays;
			}
		}		
----------------------------------------------------------------------------------------------

this - current class 
	- to call instnace methods and instnace variables.
	this.m1();
	this.age = age;
	
this()	- to call another constructor
	this();
	
super - super class 
	- to call instnace methods and instnace variables from super class.
	super.m1()l
	
	
super()	- to call another constructor
	super(1);
	
	
02-10-18 OOPS
-------------
- Object
- class 
- method - behivour/actions
- variables. - state/properties

Features:-
	- Data hiding
	- Encapsualation	
	- Inheritance
	- Abstraction
	- Polimorphism	

1.Data hiding:
		Declare all instance variables as private called data hiding. 
		From outside class, can't change these value.
		E.g:
		class Person {
			//hiding our instance variables.
			private int age;
			private String name;
		}
		
2. Abstraction
	Providing some service and hiding the internal implementation is called abstraction.
	E.g Atm is providing some service, we don't know it is working, means we dont know internal implementation.
		
		public void setAge(int age){}
		
3. Encapsualation:
		Data hiding + abstraction 
		E.g:
------------------------------------------------------------------------------------------
	class Person {
		//hiding our instance variables.
		private int age;
		private String name;
		
		public void setAge(int age){
			this.age = age;
		}
		
		public int getAge(){
			return age;
		}
		
		public void setName(String name){
			this.name = name;
		}
		
		public String getName(){
			return this.name;
		}
	}
	
	class PersonDemo {
		
		public static void main(String... args){
			Person p = new Person();
			p.setName("Sud");
			//p.age = 40;//invalid
			p.setAge(20);
			System.out.println(p.getName());
			System.out.println(p.getAge());
			
		}
	}
------------------------------------------------------------------------------------------
4.Inheritance
	- Acquiring parent properties and methods.
	- Code reusability.
	- Reduce the code amount
	
- Using 'extends' keyword, we can achive the inheritance.
	class A extends B {
	}
	Here B - parent
		 A - Child
		
----------------------------------------------------------------------------------
	class Parent{
		int property = 100000;
		static int cash = 1000000;
		
		public String toString(){
			return "property "+ property;
		}
	}

	class Child extends Parent {
	
	public static void main(String... args){
		Child c = new Child();
		System.out.println(c.property);
		System.out.println(c.cash);
			System.out.println(c.toString());
		}
	}
----------------------------------------------------------------------------------
Inheritance types:
1. Single Inheritance
2. Multiple Inheritance
3. Multi level Inheritance

	
1. Single Inheritance
	A class which extends only one class, it is called single inheritance.
--------------------------------------------------------
class A {
	int cash = 20;
	
	public int getCash(){
		return cash;
		}
	}
	//single inheritance
	class B extends A{
		
		String property = "5 hecres";
	}
----------------------------------------------------
2. Multiple Inheritance:
- A class which extending more than one class is called multiple inheritance.
- This is not possible in java

Why multiple inheritance is not possible in java?
If one is extending more than one class, if same method is avaiable in both parents, then compiler doesn't to which method it has call from which parent.
1
Eg: In the below C class, 	When calling c.getCash() method, getCash method is available in both parent classes, compiler doesn't from which class, it has call. that's why in java multiple inheritance is not possible.
-------------------------------------------------
class A {
	int cash = 20;
	
	public int getCash(){
		return cash;
	}
}
class B {
	int cash = 20;
	
	public int getCash(){
		return cash;
	}

}
//multiple inheritance
class C extends A, B{
	
	String property = "5 hecres";
	public static void main(){
		C c = new C();
		c.getCash();
	}
}
-------------------------------------------------
3. Multi level Inheritance
- One class having more than 1 parent ansisters called multilevel inheritance.
	A  - grand parent
	|
	B  - parent
	|
	C  - child

-----------------------------------------
class A{
}
class B extends A {
}
class C extends B{
}
-----------------------------------------
	
Object:
-------
- It is avaiable in java.lang package
- It is super class for all classes in java.
- If any class is not extending any other class, jvm will extends Object class by default.
	- 11 methods.

https://docs.oracle.com/javase/8/docs/api/

Method calling in inheritance:
1. We can create object child class and refer as child class
	C object = new C();
	- Using child class reference, we can call all child class methods and all its parent class methods and variables also.

2. We can use parent class reference to hold the child class object.
	B object = new C();
	
	- When ever we holding child class object using parent class reference, we can't call the child class methods or variables using parent class reference.
	object.printMyValues(); gives error because parent class reference is hold child object.
	
3. If we want to call child class metods using parent class reference, we need to do type casting.

Type casting:
	Casting the type(Changing the type)
	B objecct = new C();
	C obj1 = (C) object;
	
	obj1.printMyValues();

	-----------------------------------------------------------------
	
	class A {
	int cash = 20;
	
	public int getCash(){
		return cash;
	}
}

//single inheritance
class B extends A{
	
	String property = "5 hecres";
}


class C extends B {
	public static void main(String args[]){
	
		B object = new C();
		System.out.println(object.getCash());
		System.out.println(object.hashCode());
		
		//type cast
		// A obj1 = object;
		 C obj1 = (C)object;
		obj1.printMyPropery();
		
	}
	
	public void printMyPropery(){
		System.out.println("property:"+ property);
	}
}
-----------------------------------------------------------------
overloading:-method signature: method name and method parameters
	public void m1(int a){}

m1(int a)
--------- -> method signature: method name and method parameters.
	- Return type and access specifier are not part of method signature.


Methods which have same name but with different signature.
1. same method name but different numbmer of parameters
	class OverloadingExample {
		
		public void m1(int a){
		}
		
		public void m1(){
		}
	}

2. same method name but parameter type order is different.
		class OverloadingExample {
		
		public void m1(int a){
		}
		
		public void m1(String a){
		}
	}


class OverloadingExample {
	
	public void m1(int a, String b){
		System.out.println(" int string");
	}
	
	public void m1(String a, int b){
	System.out.println(" string int");
	}
	
	public int m2(int a, String b){
		return 1;
	}
	
	public static void main(String[] args){
		OverloadingExample a = new OverloadingExample();
		a.m1(10, "10");
	}
}

Static binding:- 
Compiler knows which method to call based on the code, it is called static binding or compile time binding.

- Mehtod overloading is early bindng or compile time binding or static binding.

- We can achive the same funtionality.
- we can increase the readability.
- In single class we can achive overloading.


Overriding:
----------
- When we are not satisfied with the super class method implementation, we should go for overidding.

- With same method name, same return type and same access specifier in the child class as same as parent class is called overriding.

- In a single class we can't achive overidding.

------------------------------------------------------
class Parent {
	int cash = 200000;
	
	public void marry(){
		System.out.println("marry subbalaxi");
	}
	
}

class Child extends Parent{

	public static void main(String args[]){
		Child c = new Child();
		System.out.println(c.cash);
		c.marry();		
	}
		
	public void marry(){
		System.out.println("I want to maryy Tamanna");
	}	
}
------------------------------------------------------
- Even though we are holding a Child class object with parent class reference, overidding method will be called always.
------------------------------------------------
class Parent {
	int cash = 200000;
	
	public void marry(){
		System.out.println("marry subbalaxi");
	}
	
}

class Child extends Parent{

	public static void main(String args[]){
		Parent c = new Child();
		System.out.println(c.cash);
		c.marry();		
	}
		
	public void marry(){
		System.out.println("I want to maryy Tamanna");
	}	
}
--------------------------------------------------

Runtime Binding:
When override any methods, compiler doesn't know to which method it has call, so JVM will identify that in runtime, so it called Runtime Binding.
- overriding is runtime binding example.

- final methods we can't override.
-------------------------------------------
	E.g:
	class Parent {
	int cash = 200000;
	
	public final void marry(){
		System.out.println("marry subbalaxi");
	}
	 
}

class Child extends Parent{

	public static void main(String args[]){
		Parent c = new Child();
		System.out.println(c.cash);
		c.marry();		
	}	
}
----------------------
- for private methods overidding is not possible.

- While overidding, we can increase access specfier scope but we should not decrease it's scope.

access specfier order
public > procted > default > private

working eg: Here we are increasing access specfier scope in child,
---------------------------
class P {
	void m1(){}
}
class C {
	void m1(){}
	
	//or
	procted void m1(){}
	
	//or
	public void m1(){}
}
---------------------------
	
Not	working eg: Here we are decreasing access specfier scope in child
---------------------------
class P {
	public void m1(){}
}
class C {
	void m1(){}
	procted int m1(){}
}
---------------------------
Differencs between Overriding and Overloading
------------------------------------------------------------------------------------
points						Overridig					Overloading
------------------------------------------------------------------------------------
1. Method signature			should be same				method signature should be different.
2. can we change return		can't change return type 	can change return type.

3. Can we change acces		We can the access specific 	we can change
	specifier				but we should increase.
	
4. Single class				No, we need inheritance		Yes,it is possible.

5. Binding 					Runtime binding				Static Binding

------------------------------------------------------------------------------------
Polymorphism:-
- Same object is behavihing differently at differnt times.

-----------------------------------------------------
class Parent {
	int cash = 200000;
	
	void marry(){
		System.out.println("marry subbalaxi");
	}
	
}


class Child2 extends Parent {

}


class Child extends Parent{

	public static void main(String args[]){
		Parent c = new Child();
		System.out.println(c.cash);
		c.marry();
		
		Parent p = new Child2();
		System.out.println(p.cash);
		p.marry();
		
		p = new Child();
		System.out.println(p.cash);
		p.marry();
				
		int a = 20;
		System.out.println(a);
		
		a = a + 5;
		a = a + 15;
		System.out.println(a);
	}
		
	protected void marry(){
		System.out.println("I want to maryy Tamanna");
	}	
}
-----------------------------------------------------
- We can achive abstraction. 

14-10-2018
Typecasting:
-----------

Casting the one type data to another.
--------------------
Eg:
class TypeCasting {
	public static void main(String[] args){
		int a = 1;
		byte b = (byte)a;
		
		System.out.println(a);
		
		TypeCasting c = new TypeCasting();
		
		A obj = new B();
		c.display(obj);
		
	}
	
	public void display(A a){
		System.out.println(a);
	}
}

E.g:
class TypeCasting {
	public static void main(String[] args){
		TypeCasting t = new TypeCasting();
		
		A a = new B();
		a.m1();
		
		B b = (B) a;
		b.m2();	//ce
		
		A a1 = new C();
		C c = (C) a1;
		
		a1.m1();
		c.m3(); //ce
		
		A a3 = new A();
		a3.m1();
	}
}

class A {
	public void m1(){
		System.out.println("m1");
	}
}

class B extends A {
	public void m2(){
		System.out.println("m2");
	}
}

class C extends A {
	public void m3(){
		Sys tem.out.println("m3");
	}
}
-------------------------
	A a = new B();
	B b = (B) a;
	
1 - B - class/interface
2 - b - reference variable/ object reference
3 - B - class/interface
4 - a - reference variable/object reference

Compiler rules:
1. Is there a relationship between 3 & 4. Either parent to child or child to parent. Otherwise it gives a compile time error

2. 3rd should be either same type or its child of 1st.
	As per example, B should be same as B or its child.
 ---------------------------------
 		A a = new B();
		a.m1();
		
		B b = (A) a;
 ---------------------------------
 
Runtime rules
3. 3rd type and 4th type object should be same. Otherwise we will get ClassCastException.

------------------------------
		A a = new B();
		a.m1();
		
		B b = (B) a;
		// B b = (A) a;
		
		b.m2();
		
		A a1 = new C();
		C c = (C) a;	//RE: CCE
		
------------------------------
instanceof:
- To avoid the ClassCastException, we should use 'instanceof' keyword.
- instanceof returns true only when reference is not null and object type is same.
- To use the instanceof operator, there should be relation either parent to child or child to parent.
Case 1:		
		A a1 = new C();
		
		//a1 = null;
		if(a1 instanceof C){
		}

	Here:	
		a1 instanceof C	returns true. Because a1 object is C.

Case 2:		
		A a1 = new B();
		
		//a1 = null;
		if(a1 instanceof C){
		}

	Here:	
		a1 instanceof C	returns false. Because a1 object is B.
Case 3:		
		A a1 = null;
		if(a1 instanceof C){
		}

	Here:
		a1 instanceof C	returns false. Because a1 is null.
Note: null is not any type.
	
Case 4:		
		C c = new C();
		if(c instanceof A){
		}

	Here:	
		c instanceof A - returns true. Because c is child of A
		
Case 5:		
		A a= new A();
		if(a instanceof C){
		}

	Here:	
		c instanceof A - returns false. Because a is not child of C. 
		
		
Summary:
	x intanceof y
	x - object reference
	y - Class/interface name
	
		true	
			- x and y should be same
			- x is child and y is parent
		false
			- x is null
			- x is parent and y is child 
	
-----------------------------------------------------------------------------------------
Pojo: Plain Old Java Object:
	- Only instance variables
	- only setter and getters will avaiable.
	- constructor.
	
-----------------------------------------------------------------------------------
	class Person {
		//hiding our instance variables.
		private int age;
		private String name;
		
		public void setAge(int age){
			this.age = age;
		}
		
		public int getAge(){
			return age;
		}
		
		public void setName(String name){
			this.name = name;
		}
		
		public String getName(){
			return this.name;
		}
	}
------------------------------------------------------------------------
16-10-2018
interface:
- Interface also like a class. It has methods and static variables.
- interface should not have construcors, blocks and instance varaibles.
- we can't create objects for interfaces. so instance variables are not allowed.
- untill java 1.7 static methods should not write interfaces.

- all variables in interface are "public static final". If developer is not adding them, compiler will add these for all variables in interface.

- Final variables must be initilized.
	public static final int personalLoanRate; //CE: must be init
	public static final int personalLoanRate = 20; //Ok

- final variables can't be changed.
- final variables can be accessed through class.variablename

- in interface, only public access modifier is allowed for variable. private and protected are not allowed. 
-----------------------------------------------------
interface Loan {
	public static final int carLoanRate = 15;
	int peronalLoanRate = 20;
	static int houseLoanRate = 25;
	//private static int houseLoanRate = 25; //CE
	//protected static int houseLoanRate = 25; //CE
}


class LoanTest {
	static int a;
	public static void main(String[] args){
		LoanTest.a = 25;
		// Loan.peronalLoanRate = 30;
		System.out.println(Loan.carLoanRate);
		System.out.println(Loan.peronalLoanRate);
		System.out.println(LoanTest.a);
	}
	
	
}
----------------------------------------------------------
abstract methods:
 - A method which doesn't have any body is called abstract methods.
 - by using 'abstract' keyword in the method, we can abstract method.
 
- By default all metods in interface are abstract methods.

- If developer explicitly declared method abstract then compiler will not add.
- if developer is not adding 'public abstract', then compiler will add them for each method.
- private and protected are not allowed for methods in interface.

- By using 'implements' keyword , A class can implement an interface.
E.g:

	interface Loan {}
	class PLoan extends Loan {} //CE
	class PLoan implements Loan {} //OK
	
- If any class is implementing an interface, then that class must provide the implementation (body for methods) for all abstrct methods.otherwise we will get comile time error.

--------------------------------------
interface Loan {
	public static final int carLoanRate = 15;
	int peronalLoanRate = 20;
	static int houseLoanRate = 25;
	
	void calculateIntrest();
	public abstract void calculatePersonalIntrest();
}

class PersonalLoan implements Loan{

	public void calculateIntrest(){
		System.out.println("Calcaulate intrest");
	}
	
	public void calculatePersonalIntrest(){
		System.out.println("Calcaulate personal intrest");
	}
}

class LoanTest {
	static int a;
	public static void main(String[] args){
		LoanTest.a = 25;
		// Loan.peronalLoanRate = 30;
		System.out.println(Loan.carLoanRate);
		System.out.println(Loan.peronalLoanRate);
		System.out.println(LoanTest.a);
		
		Loan p = new PersonalLoan();
		p.calculateIntrest();
		p.calculatePersonalIntrest();
		
	}
}
-------------------------------------
25-10-2018 Abstract classes

- A class which is declared with abstract keyword.
- abstract keyword can be used only to methods and classes but not for variables.
- abstract keyword should be before class keyword.
- for abstract classes we can't create a object.
- If atleast one abstract method is there in a class then that class must be declared as abstract class. otherwise we will get compile time error.
- We can have any number of concreate methods and abstract methods.
- even if there is no abstract method in a class still we can declare that class as abstract.
-----------------------------------
abstract class AbstractExample {
	
	public void m1(){
		System.out.println("m1");
	}

}
-----------------------------------

methods:-
1. concreate methods
	A method which has method body.
2. abstract methods
	A method which doesn't have a body.
	
- When ever we are extending any abstract class, then child class must provide the body for all parent class abstract methods. otherwise we have to declare child class as abstract. 
- In abstract class we can have instance variables, static variables, instance methods, static method and construcors.
----------------------------------------------------
abstract class AbstractExample {
	int a = 20;
	
	public abstract void calculateIntrest();
	public void m1(){
		System.out.println("m1");
	}

}

class AbChild extends AbstractExample {
	public void calculateIntrest(){
		System.out.println("child cal");
	}
}


class AbstractDemo {
	public static void main(String[] args){
		AbstractExample a = new AbChild();
		a.calculateIntrest();
		System.out.println(a);
		
	}
}
----------------------------------------------------


interface -> interface => extends
-------------------------
interface A {
}
interface B extends A {
}
---------------------------

class => class => extends
-------------------------
class A {
}
class B extends A {
}
---------------------------


interface => childClass => implements
-------------------------
class A {
}
class B implements A {
}
---------------------------

class => interface ==> This is not possible in java
-------------------------
class A {
}
interface B extends A {
}
---------------------------

- One class can implement any number of interface at same time. So we can achive multiple inheritance through interfaces.

Question: how multiple inheritance is possible in java?
Yes, multiple inheritance is possible only through the interfaces but not with classes.

--------------------------------------------------------------
interface A {
	void m1();
	
}

interface B {
	void m1();
}

class C implements A, B {
	public void m1(){
		System.out.println("c m1");
	}
}

class InterfaceTest {
	public static void main(String[] b){
		A a = new C();
		a.m1();
		
		B b = new C();
		b.m1();
		
		C c = new C();
		c.m1();
		
	}
}
--------------------------------------------------------------
final:
------
final is a keyword. it can be used for below 
1. variables
2. methods
3. classes

Final variables
- Final variables must be initilized.
	final int a =10; //OK
	final int b; //CE
	
- final variables can't be changed.
	final int a = 20;
	a = 50; //CE:
	
Final metods:
- final methods we can't override.
-------------------------------------------
	E.g:
	class Parent {
	int cash = 200000;
	
	public final void marry(){
		System.out.println("marry subbalaxi");
	}
	 
}

class Child extends Parent{

	public static void main(String args[]){
		Parent c = new Child();
		System.out.println(c.cash);
		c.marry();		
	}	
}
------------------------------------------
Final class
- Final classes we can't extend.
------------------------------
final class Parent {
	public void cal(){
		System.out.println("Subbamma");
	}
	
}

class Child extends Parent {
public void marry(){
		
	}
}

- We can't use final keyword with abstract keyword. Where abstract refers inheritance and final refers no inheritance.

abstract final class A {
}	//CE
------------------------------

Packages:
--------
https://www.javatpoint.com/package
What is package?
- package is a group of classes or interfaces.


Why we should use package? 
- For easy maintainance
- readability
- we can avoid name collusion.

- It should 1st statement.
- package name should be like this: com.companyname.packagename 
	com.ss.math;
	
Compilation:
Without package:
	javac A.java
	
With package
	javac -d . A.java
	javac -d b A.java
	javac 	- javac compiler
	-d 		- directroy (destination folder)
	. 		- current folder
	b 		- folder name
	
Running:
Without package:
	java A
	
With package
	java com.ss.pack.A
	java 	- To call the jvm to execute our program

package types:
1. Built in packages
	The already defined packages in java
		java.lang
		java.math
		java.utils
		java.io
	
2. user defined packages:
	- packages which are created by us.
	
	
	
import:
-------
-To use from other package classes in our class, we have to import that class first.
- compiler tries to check the class is available in current package, if it is not avaibabl,it gives compiler time error.
- import statement specifies to compiler to check the class in other package.
- import should be after package statement.

Order: order of apperance
	pacage
		|
	import
		|
	class
	
- If any class is public, then file name should be same.
- In one file, only class can declare as public

absolute class name:
a class name with package name	
	com.ss.pack1.StringUtil

There are three ways to access the package from outside the package.

1. import package.*;
	- All classes will imported.
	
2. import package.classname;
	- Only specified class will be imported.
	
3. fully qualified name.
	- Only specified class.
----------------------------------------------------------------
30-10-2018	
Access modifier/specfier: Which specify the access from other classes.
1. public 
2. protected
3. default
4. private

1. public 
	We can access from anywhere
	
2. protected
	We can access with in the class, with in the curret package  and with in the child classes from outside package.
	
3. default
	We can access with in the class and with in the curret package (folder).

4. private
	Only with in the class. From outside class can't call private methods.

------------------------------------------------------------
package com.ss.pack;

public class A {
	public static void main(String[] a){
		System.out.println("Hello package");
		a1();
		a2();
	}
	
	
	private static void a1(){
		System.out.println("a1 private method");
	}
	
	static void a2(){
		System.out.println("a2 default method");
	}

	protected static void a3(){
		System.out.println("a2 public method");
	}
	
	public static void a4(){
		System.out.println("a2 public method");
	}
}



package com.ss.pack;

import com.ss.pack1.MathUtil;
// import com.ss.pack1.*;

class B {
	public static void main(String[] a){
		System.out.println("Hello package B");
		
		int val = MathUtil.squre(10);
		System.out.println(val);
		
		int val1 = com.ss.pack1.StringUtil.squre(10);
		System.out.println(val1);
		
		//A.a1();
		A.a2();
		A.a3();
	}
}


package com.ss.pack1;
import com.ss.pack.A;

public class C extends A{
	public static void main(String[] a){
		System.out.println("Hello package C");
		//A.a2(); can't call because it default.
		//A.a3();
		
		C c = new C();
		// d.a1();
		// d.a2();
		c.a3();//C is child of A
		c.a4();
		
	}
}

class D{
	public static void main(String[] a){
		System.out.println("Hello package C");
		//A.a2(); can't call because it default.
		//A.a3();
		
		D d = new D();
		// d.a1();
		// d.a2();
		d.a3();//CE: D is not a child of A
		d.a4();
		
	}
}
------------------------------------------------------------
Class:
- For class only applicable modifier are:
	1 - public 
	2 - default 
	3 - static 
	4 - abstract
	5 - final 
	
	public class A{}	//OK
	protected class A{} //CE
	public abstract class A{}	//OK
	public abstract final class A{}	//CE abstract and final combination wrong.
	
-------------------------------------------------------------
31-10-208
java lang package:
https://docs.oracle.com/javase/8/docs/api/index.html?java/lang/package-summary.html

interfaces:
	Appendable
	AutoCloseable
	CharSequence
	Cloneable
	Comparable
	Iterable
	Runnable

Classes:
	Boolean
	Byte
	Character
	Class
	Double
	Enum
	Float
	Integer
	Long
	Math
	Number
	Object
	Runtime
	Short
	String
	StringBuffer
	StringBuilder
	System
	Thread
	ThreadGroup
	ThreadLocal
	Throwable
	Void
	
	
1. String
2. StringBuffer
3. StringBuilder
4. Object
5. Math

----------------------------
Math	
	1. min
	2. max
	3. abs
	4. random
	5. round
	6. ceil
	7. floor
	
	
String
- String is a final class. So we can't extend String class.
- String is a immutability class.

What is immutability?
When ever we are trying to change anything in the object, it will create a new object with modifications. The existing object will not change.
	E.g:
		String s = "Sudha";
		
	When we are calling concat method, it will create a new string as 'sudhakar' but in the s it will not change.
		s.concat("kar");

	If we want to hold the changed object then 
	s = s.concat("kar");
	
Constructors:
	String()
	String(char[] a)
	String(String s)
	String(StringBuffer buffer)
	String(StringBuilder builder)

Methods:
	1. length()
	2. isEmpty()

how to instantiate string?
String a = "Sudha";
String b = new String("Sudhakar");

a.isEmpty();	//false
------------------------------------