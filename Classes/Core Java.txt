-------------------------------------------------------------
03-07-2018 Tuesday
-------------------------------------------------------------
1. Install java
	
2. Verify java installation
	1. By manual process
		Go c drive -> program files -> java

		Program files --> 64 bit os
		Program files(x86) --> 32bit os
	
or
	open cmd prompt
	cmd -> type java and enter
	
	2. Verify java version by typing below command in cmd
		java -version 
			YOu should see the below screen.	
			java version "1.8.0_162"
			Java(TM) SE Runtime Environment (build 1.8.0_162-b12)
			Java HotSpot(TM) 64-Bit Server VM (build 25.162-b12, mixed mode)

Opening cmd promps
	1. win + type cmd 
	2. win+R and type cmd
	3. shift + right click -> Open powershell window option here.
-------------------------------------------------------------
1. All files must end with .java extension.
-------------------------------------------------------------04-07-2018	Wednesday
-------------------------------------------------------------What is Java?

What are java editons?
--------------------------------
What is Java?
Java:
	- Java is high level, object oriented programming language. 
	- It is an API and it is an Open source.
  program:
	- Set of line which performs a task.	E.g Adding 2 numbers
	
  Object:
	- Any things which is existing in the real world. E.g: A dog
		- properties: which it has. 	E.g: A dog has 4 legs, A man has 2 legs
		- Actions:	which it can performs	E.g: it can bow bow.
	
  API: Application Programming Interface
	- A set of guide lines with classes and interfaces

  Open source:
	- Freely available. 

	
What are java editons?
Types:
1. JSE: Java Standard Edison
2. J2EE: Java Enterprise Edition
3. J2ME: Java Micro Edition
4. JavaFx


1. Java SE: Java Standard Edison
	- Basics programming
	- standalone appliations: It will run only on a machine.
	- we can't write web applicatons.
	
2. J2EE: Java Enterprise Edition
	- To write web appliations.
		- which runs on the internet
			E.g: internet banking, whatapp web, facebook
	
3. J2ME: Java Micro Edition
	- Create mobiles applications.
	
4. JavaFx
	- To create the internet applications.
-------------------------------------------------------------05-07-2018 Thursday
-------------------------------------------------------------What are the java versions and History?
James Gosling , Mike Sheridan, and Patrick Naughton started java language project in 1991.
- first java named as Greentalk.
- then they renamed as Oak. Oak - strength. Other company registered with oak technoloy so they changed to Java.
- They named as Java.
- Java is only a name and abbrevation.
- Sun micro systems developed java technoloy.
- JDK 1.0 released in(January 23, 1996).

Java Version History
There are many java versions that has been released. Current stable release of Java is Java SE 10.

JDK Alpha and Beta (1995)
JDK 1.0 (23rd Jan, 1996)
JDK 1.1 (19th Feb, 1997)
J2SE 1.2 (8th Dec, 1998)
J2SE 1.3 (8th May, 2000)
J2SE 1.4 (6th Feb, 2002)
J2SE 5.0 (30th Sep, 2004)
Java SE 6 (11th Dec, 2006)
Java SE 7 (28th July, 2011)
Java SE 8 (18th March, 2014)
Java
 SE 9 (21st Sep, 2017)
Java SE 10 (20th March, 2018)

What we can do with Java?
- We can create web applications.
- we can create games.
- we create android apps.
- we can use java in televisions and setup boxes
- we can create mobile applications.

What are the features?
-- Once learn the basic programs
-------------------------------------------------------------
Basics
--------------------------------------------------------------
- Simple java program

Reserved/keyword words: 51
	- It has some meaning to java compiler. 
	- All reserved words in small letters only.
1. class - to declare a class.
2. public - 
3. static - 
4. void - It returns nothing. 

5. byte - 1byte -127 to 127
6. short	- 2bytes 
7. int 		-  4 bytes
8. long		- 8 bytes
9. float	- 4 bytes
10. double	- 8 bytes
11. char 	- 2 bytes
12. boolean - true/false

13. true
14. false 

15. if
16. else 
17. switch
18. case
19. break

20. extends
21. implements
22. this
22. super


how to compile
	javac filename.java
	E.g: javac welcome.java

How to run a java program
	Syntax: java classname
	E.g: java A	
	
task:
1. Write a program. HelloWorld.
	print out: Hello Murali, welcome to chennai.
	
-----------------------------------------
0-07-2018
-----------------------------------------
How to write a java program?
- A file with .java extension called a java file.

How to compile a java program?
- javac file name with extension
	E.G: javac Addition.java
	
How to run a java program?
	Syntax: java classname
	java Addition
	
What is platform independant?
JRE, JDK and JVM?
- Same program will run in linux, windows without recompiling it. It runs on anywhere.

Tasks:
- Write a-z java files and compile them?

-------------------------------------------------------
07-7-2018 Saturday
-------------------------------------------------------
Building blocks:
1. Class
2. variables
	1. instance
	2. static
	3. local
	
3. methods
	1. instace 
	2. static
4. constructors.
	1. default
	2. parameter
	
5. blocks.
	1. instance
	2. static
	
how to declare a java class?
1. Class:
	- using class keyword we can declare a class.
	Syntax: 
	class Addition {
	}

	- All building blocks (variables, blocks, constructors and methods) should be inside a class. if we are declaring out side, compiler will give you an error. 
		Welcome.java:5: error: class, interface, or enum expected
		int i = 10;
		^
		1 error

2. variables:

------------------------------------------------------
09-07-2018 Monday
------------------------------------------------------
Identifiers: A name of class or variable or a method name called identifier.
	class Test {
	}
	
	eg: Here Test is identifier. It is a name of a class.
	
- A name of variable.
	int salary = 20000;
	-------------------
	int - datatype
	salary - variable name - identifier
	200000 - value/literal.
	
- A name of method.
	public static void main(String args[]){}
	--------
	main - name of a method.
	args - variable - identifier

Identifier naming rules:
class:
	- It should start capital letter and camel case.
		MethodExample

Method/variable:
	- It should start small letter and camel case
		int length;
		methodOne(){}
		int a[]; a.length


Identifiers Naming rules:-
1. Only a-z, 0-9,_ and $ allowed in identifiers.
	int age = 20;
	int #age = 30;	//invalid
	int age$ = 40;	
	int man age = 50; //invalid: Space should not be there in identifier
				//Error: 
	
2. Identifier name should not start with numbers.
	int sno1 = 20;
	int sno2 = 30;
	int 1sno = 10;	//invalid
	int man_age = 20;
	int $age = 60;
	int class = 20; //invalid
	
3. should not use reserved words.
4. Name should not contain any white spaces
	int a b = 30; //invalid
-------------------------------------------------------------
Data types:
Pre defined data type or primitive data types.
1. Numeric/numbers
	1.1 Real numbers (1)
		1. byte
		2. short
		3. int
		4. long
	1.2 Fraction numers (0.2323)
		1. float
		2. double
2. boolean type
	1. boolean
3. char tye
	1. char

Data type:
which type of data it is.
	byte a = 10;`//valid
	byte b = false;	//invalid
		VariableExample.java:6: error: incompatible types: boolean cannot be converted to byte
                byte b = false;
				
1. byte:
	Range: -128 to 127
	memory: 1 byte = 8 bits
	E.g: byte b = 120; //valid
		 byte c = 140; //invalid: possible loss of precision
		 byte d = -130; //invalid
		 
2. short
	range -32768 to 32767
	memory: 2 bytes = 2power16
		E.g: short s = 200;
			short s1 = 32769; //invalid possible loss of precision
			
3. int 
	range: 2147483647
	memory: 4 bytes = 2power32
		int i = 1;
		int i2 = 2000;
		int i3 = 2147493847;	//invalid
		int i4 = b + s;	//valid.

4. long	
	range: -9,223,372,036,854,775,808  to 9,223,372,036,854,775,807
	memory: 8 bytes = 2power64
	long l = i + i2;
	byte b = i+ i2;	//invalid
	
	
5. float
	4 bytes = 32 bits.
	up to 7 points it can store.
	float f  = 23.011232323232323234545f;
	float f1 = 220.2; //invalid, decimal values always referred as double value.
	
	
6. double 
	8 bytes = 64 bits	
	up to 14 points it can store.
	double d = 12.0;	
	double c = 12;
	double d1 = 10.0d;
	double d1 = 10.0f;
	double d3 = false;	//invalid
	
------------------------------------------------------------
byte --> short --> int --> long --> float --> double       |
-------------------------------------------------------------
	long l = 222222;
	float f = l;	//valid
	
	double l = 222222;
	float f = l;	//in valid
	
--------------------
7. char: 
	Range: 65636
	2bytes : 2power16
	char i = 'm';
	char b = 'Z';
	char c = 'A' or 65;
	char d = 100; //valid
	char e = 666666; //invalid

8. boolean
	boolean b = true;
	boolean c = false;

--------------------------------------------------------------
String:
It is a class.
	String name = "Sudhakar";
	String s = 100;	//invalid 	CE: incompatible types
	String s2 = "200";
	
Tasks:
	take a class and print the values -> PrintValues
	
		- name
		- age
		- dob
		- father name
		- village name 
		- income
		
2. write programs for sum, substraction, div and mul for int, long and double.
-------------------------------------------------------------
Control statements:
if
if else
else if
switch

1. if 
	If we have only one condition, then should go for if case.
	E.g: Print whether given number is even
		if(xx){
		}
xx - only boolean type or boolean result
	if(i % 2 == 0){}	//
	
- brackets optional
- If no brackets are there, then only one line is in if block
- always boolean type is required 
	- boolean expression
	 1 == 2 ==> false
	 1 == 1 ==> true
	 1 != 1 => false
	 int i = 10 ==> ce	
---------------------------------------------------------------
class IfExample {
	public static void main(String args[]){
		int i = 10;
		boolean b = false;
		
		if(b){
			System.out.println("Boolean value is true");
		}	
		
		if( i == 10){
			System.out.println("I value is "+ i);
		}
		
		if(i % 2 == 0){
			System.out.println("Even number");
		}
		
		if(b)
		System.out.println("First line");
		
		System.out.println("second line");	
	}
}

---------------------------------------------------------------
2. if else
	If we want show something when if condition is failed, means we have 2 condtions. 
		if(age > 18){
			SOP("You are elegible for vote");
		}
		else{
			//you are not elegible
		}

- If if condition is failed then only else will be execued.
		
3. else if
	If we have more than 2 condions , then we should go for else if.
		if(condition){
		}
		else if(condions){
		
		}
		else if(condions){
		
		}else {	//optional
		
		}
-------------------------------------------------------------
class IfExample {
	public static void main(String args[]){
		int marks = 25;
		
		if(marks >= 60 && marks < 70){
			System.out.println("first class");
		}		
		else if(marks >= 70 && marks < 80 ){
			System.out.println("Distinction");
		}
		else if(marks >= 80 ){
			System.out.println("Topper");
		}
		else if(marks < 35){
			System.out.println("Failed");
		}		
		else {
			System.out.println(" Just Pass");
		}
	
		System.out.println("End");
	}
}

//should not write like this.
//because it executes all if statements in the program.
class IfExample {
	public static void main(String args[]){
		int marks = 25;
		
		if(marks >= 60 && marks < 70){
			System.out.println("first class");
		}
		
		if(marks >= 70 && marks < 80 ){
			System.out.println("Distinction");
		}
		
		if(marks >= 80 ){
			System.out.println("Topper");
		}
		
		if(marks < 35){
			System.out.println("Failed");
		}		
		else {
			System.out.println(" Just Pass");
		}
	
		System.out.println("End");
	}
}

-------------------------------------------------------------
3. switch

- If we have more than 2 condions , then we should go for switch.
	
syntax:
	switch(xx){	//
	}
xx - should be byte, short, int, char, String, boolean, enum.
		int i = 10;
		switch(i){
		}
		
- Not allowed in case arguments - float, long, double.

case: each condition is called as case.


switch(xx){
	case 1: {
	}
	
	case 2: {
	}
	default: {
	}
}
points:
- syntax: 
	switch(xx){
		case 1: {
		}
		
		case 2: {
		}
		default: {
		}
	}
1. xx - byte, short, int , String, enum and boolean
2. cases are optional. even default also optional.
3. case can be in any order. e.g: case 3: case 2: default
4. case label duplicates are not allowed.
5. default case also optional.
6. arguments (xx) and case lables (1, 2) must be same type. 
7. break - to stop the next case execution. break optional.
8. Between 2 cases nothing is allowed. we should not write even SOP also.
9. break should be used only in switch.

Assignment
write below program:
String name ="Sudha";

sudha: 27
mural: 21
venky 24
ashok: 27
prasad: 21

switch(name){
}

-------------------------------------------------------------------------------------------
class SwitchDemo {
	
	static public void main(String[] a){
		
		int age = 6;
		String s = "1";
		
		switch(age){
			case 1: {
				System.out.println("Baby");
				break;
			}
			
			case 2: {
				System.out.println("Pre class");
				break;
			}
			
			case 3: {
				System.out.println("LKG");
				break;
			}
			
			case 5: {
				System.out.println("UKG");
				break;
			}
			// System.out.println("middle");
			case 6: {
				int ab = 20;
				System.out.println("First");
				
			System.out.println("middle");
			
				break;
			}
						
			default: {
				System.out.println("Big man");
			}
		}
	}
}
---------------------------------------------------
26-7-18 Iterative statements or loops
-------------------------------
1. for
2. while
3. do while

Syntax:
	for(i;c;id){
		body
	}
	
	i -- initilization:
		int i = 1;
		
	c -- condition  - always true/false
		i < 10 --> true
		
	id -- increment/decrement
		i++	/ ++i / i = i+1
		i--	/ --i

1. init - optional
2. condition - optional -- by default value is true
3. incr/decrement - optional

flow:
	for(1;2 ;4) {
		3
	}
	Sop("compeleted");
	
	
	1 - init 
	2 - conditon
	3 - body
	4 - increment

- for loop open and close {} brackets are optional.
- if for is true always and if there are any statements below the while loop then compile time error will show as unreachable statement.
	eg.
		for(; true ;){
		}
		System.out.println("End");
------------------------------------------------------------
class PrintNumbers {
	public static void main(String[] args){

		for(int i=50; i> 0; i--){
			
			if(i % 2 == 0){
				System.out.println("Even number" + i);
			}
		}		
	}
}

class PrintNumbers {
	public static void main(String[] args){

		for(int i=0; i< 50; i++){
			
			if(i % 2 == 0){
				System.out.println("Even number" + i);
			}
		}		
	}
}
-----------------------------------------
27-07-18 while
-----------------------------------------
- When we don't know the how many iteration we want then we should go for while loop.
Syntax:
	while(conidtion){
		//body
	}
	
- condition: always boolean value/expression.
- if condition is true, while body will be executed.
- while - condition is mandatory.
- while will not execute if condition is wrong.

- if while is true always and if there are any statements below the while loop then compile time error will show as unreachable statement.
	eg.
		while(true){
		}
		System.out.println("End");
-------------------------------------------------------
class WhileExample {
	static public void main(String[] args){

		
		int j = 90;
		while(j > 100){
			if(j % 2 == 0){
				System.out.println(j);
			}		
			
			j = j -1;
		}
		
	}
}
---------------------------------------------------------------
do while:
---------
syntax;
	do {
		//Body
	}while(condition);
	
- do will execute atleast once even if condition wrong.
- break - we can use in loops also.
----------------------------------------------------------
class DoWhileExample {
	static public void main(String[] args){
		int i = 100;
		do {
			if(i % 2 == 0)
			System.out.println(i);
			i = i -1;
		}while( i > 50);
	}
}
--------------------------------------------
29-07-18	Operators
--------------------------------------------
1. Unary Operator,
2. Arithmetic Operator,
3. Shift Operator,
4. Relational Operator,
5. Bitwise Operator,
6. Logical Operator,
7. Ternary Operator and
8. Assignment Operator.

Unary Operator:
	1. pre increment
	2. pre decrement
	3. post increment
	4. post decrement
	5. ~
	6. !

1. pre increment: First increment will happen
	++x;
	 int x = 10;
	 
	 ++x; //11
	 
2. pre decrement: First decrement will happen
	--x;
	int y = 20;
	--y; //19

3. post increment: It will not increment in the current line, incrment will happen in second.
	 int x = 10;
	 Sop(x++); 10
	 Sop(x); 11
	 
	 
4. pre decrement: It will not decrement in the current line, decrement will happen in second.
	int y = 10;
	 Sop(y--); 10
	 Sop(y); 9
	 
5. not operator (!)
- It applialbe for only boolean type.
	Eg. boolean b = false;
	boolean c = !b;	//true
	int i = 10;
	int j = !i; //ce: \UnaryOperatorsDemo.java:21: error: bad operand type int for unary operator '!'
                System.out.println(!c);

6. ~ tilde operator:
- Only number types
	E.g: int y = 20;
		int z = ~y; //-21
		int x = ~z; //20
		boolean a = ~true; ce: .\UnaryOperatorsDemo.java:21: error: bad operand type boolean for unary operator '~'
                System.out.println(~value);
				

2.1 Arithmetic operators
	int a = 10;
	int b = 3;
	+	= a + b; 13
	-   = a -b; 7
	*   = a * b; 30
	/	= a/b; 3
	%	= a%b; 1
	
3. Relational operators
	int a = 20;
	int b = 30;
	<	==> a < b == true
	>	=> a> b	==false
	<=	=> a <=b == true
	>=	=> a >= b = false 
	==	=> a == b == false 
	!=	=> a != b == true
	
4. Logical operatos:
	Double AND &&
	doble OR || 
	
	&& -> if both conditions are true then only it will be true.
		- If first condition is true then only second condition will be executed.
		
		int x = 30;
		
		if( x > 20 && x < 30){	//total result false. 1st condition is true but second condition is false so result is false.
			System.out.println("more than 20 and less then 30");
		}
		
	|| -> if both conditions are false then only it will be false, in all other scenarios it will be true.
		- If first condition is true then second condion will not be execued.
		int x = 25;
		if( x > 20 || x < 30){
			System.out.println("or operator more than 20 or less then 30");
		}
		
Ternary operator;
	?:
E.g:
	int y = 1;
	
	int age = y <0 ? 0 : y;
	System.out.println(age);
	
Bitwise operators:
&	- true & true = true 
	- true & false = false
	- false & false = false
	
|	- true | true = true 
	- true | false = true
	- false | false = false
	
^ 
- this is applicable only for numbers
-----------------------------------------------------------
30-7-18 Arrays
-----------------------------------------------------------
int r1 = 1;
int r2 = 2;
int r3 = 3;
int r4 = 4;
.
.
int r100 = 100;
https://www.javatpoint.com/array-in-java

Array:
- To store group of homogenious (same type) values.
- Size/length is fixed.
- Array is index based. the index starts 0 and last index is size-1.
- If we are trying to get the value from array where index is greater than size, then ArrayIndexOutOfBoundsexception will occur.

syntax: array declaration:
	int[] rollNos = new int[size];
	
size -- always integer

Steps:-
1. array declaration.
	int[] rollnos = new int[9];

2. array initilization
	rollnos[0] = 100;
	rollnos[29] = 130;
	
3. Display the array data
	for(int i = 0; i < rollnos.length ; i++){
		Sop(rollnos[i])
	}

	class ArraysDemo {
	public static void main(String[] args){
		
		//declaration
		int[] a = new int[5];
		
		// value initilization.
		a[0] = 100;
		a[2] = 200;
		a[1] = 300;
		a[3] = 400;
		a[4] = 500;
		a[4] = 350;
		// a[5] = 600; //ArrayIndexOutOfBoundsException
		
		System.out.println(a);
		
		
		//value printing
		System.out.println(a[0]);
		// System.out.println(a[1]);
		// System.out.println(a[2]);
		// System.out.println(a[3]);
		// System.out.println(a[4]);
		

		for(int i = 0; i < a.length ;i++){
			System.out.println(a[i]);
		}

		System.out.println("reverse array");
		for(int i = a.length - 1; i >=0  ;i--){
			System.out.println(a[i]);
		}
		
		String[] names = new String[4];
		names[0] ="Sudhakar";
		names[1] = "venky";
		names[3] = "murali";
		
		for(int j = 0; j < names.length ; j++){
			System.out.println(names[j]);
		}
	}
}
--------------------
int a;
a = 20;

- Array can initilized in 2 lines as give below.
int[] a;

a = new int[10];
a[0] = 1;


- Array declaration and initilization in one line
	int[] numbers = {1,5,7,5,5,5,6};
	
	
--------------------
foreach loop:
--------------------
- Only for arrays an collections.
- we can't reverse elememets.


for(datatype identifier: arrayName){
  Sop(identifier);
}


class ArraysDemo {
	public static void main(String[] args){
		
		//declaration
		int[] a = new int[5];
		
		// value initilization.
		a[0] = 100;
		a[2] = 200;
		a[1] = 300;
		a[3] = 400;
		a[4] = 500;
		a[4] = 350;
		// a[5] = 600; //ArrayIndexOutOfBoundsException
		
		System.out.println(a);
		
		
		//value printing
		System.out.println(a[0]);
		// System.out.println(a[1]);
		// System.out.println(a[2]);
		// System.out.println(a[3]);
		// System.out.println(a[4]);
		

		for(int i = 0; i < a.length ;i++){
			System.out.println(a[i]);
		}

		System.out.println("reverse array");
		for(int i = a.length - 1; i >=0  ;i--){
			System.out.println(a[i]);
		}
		
		String[] names = new String[4];
		names[0] ="Sudhakar";
		names[1] = "venky";
		names[3] = "murali";
		for(String name : names){
			System.out.println(name);
		}
		
		for(int j = 0; j < names.length ; j++){
			System.out.println(names[j]);
		}
		
		int[] marks = {60, 60, 70, 35, 90, 54}; //declaration and initilization
		for(int k = 0; k < marks.length; k++){
			System.out.println(marks[k]);
		}
		
		
		//for each only for arrays and collections
		for(int x: marks){
			System.out.println(x);
		}
		// int[] abc;
		// abc = {34,22};	//CE
		
	}
}

----------------------------------------------|
 OOPS 01-08-2018
----------------------------------------------|
methods:
-------
- A group of statements which does a task.
- Should be declared directly inside a class but not inside the another method.
Uses:
- To avoid the code duplicates.
- To reuse the code.
- we can reduce no of lines code using method.
- To separate functionlity
	E.g: add - add method functionlity
	swap - swap method functionlity.


public void m1(int a){
}

public - access specfier
void - return type - returns nothing.
m1 - method name
int - parameter type
a - parameter name. 
--------------------------------
methods are 2 types:
1. Instance method.
2. static method.

1. Instance method:
 - A method which is not declared with static keyword called instance method.
 - To call the instance method, we need to create an object.

	public void m1(){}

	Steps:
	1. Declare a method in a class.
		class MethodExample {
		
			public void m1(){
				Sop("m1");
			}
		}
	2. Calling m1 method.
		1. Create a object for that class where method exist.
			MethodExample object = new MethodExample();
		2. Call the method using object.
			object.m1();
		
2. Static method:
	A method which is declared with static keyword called static method.
 - For static methods, we no need to create object. using class name we call the static methods.
 
	public static void m1(){}
	
Steps:-
	1. Declare a static method in a class.
		public static void m2(){
			Sop("m2 static");
		}
	2. Calling m1 method.
		Using Class.methodname, we can call static method.
		E.g 
			MethodExample.m2();

	
Accessing methods:
-----------------
Can we call instace method from static method?
ans: yes, we can call using object. here m2 is instance method. m1 is static method. 
m1 method is calling m2 method.

	public void m2(){
		System.out.println("m2");
	}
	
	public static void m1(){
		System.out.println("m1");
		
		MethodCallingExample mce = new MethodCallingExample();
		mce.m2();
	}
	

Can we access static method from static method?
yes, we can call using methodname directly or using Classname.methodname. here m1 and m3 are static methods. m3 is calling m1 method.

	public static void m1(){
		System.out.println("m1");
	}
		
	public static void m3(){
		System.out.println("m3");
		m1();
	}
	
Can we call static method from instance method?
yes, we call call using methodname or using Class.methodname. Here m2 is instance mehtod, m4 is static method. m2 is calling m4 method using classname.methodname.

	public void m2(){
		System.out.println("m2");
		MethodCallingExample.m4();
	}
	
	public static void m4(){
		System.out.println("m4");
	}
	
Can we access instace method from instance method?
yes, we can call. here m2, m5 are instances methods. m2 method is calling m5(). 

	public void m2(){
		System.out.println("m2");
		m5();
	}

	public void m5(){
		System.out.println("m5");
	}
-----------------------------------------	
method type | instance method	|static 		|
------------|-------------------|-------		|
instance    | yes,eg: m1()      |yes, e.g, m2()	|
------------|-------------------|-------		|
static 		 no, using object   |yes. eg:m2()	|
			  we can call. 
			  eg: obj.m1()      |    			|
------------|-----------|-------|--------------	|
	
Note:
1. If a method is calling itself then StackOverflowError will come.
	public void m1(){
		mce.m1();
	}
	
2. If 2 methods are calling each other, then StackOverflowError will come.
	p v m1(){
		m2();
	}
	
	p v m2(){
		m1();
	}
-----------------------------------------------
03-08-2018 method params
-----------------------------------------------
1. Method params.
	Varibles which are declared inside method brackets called method parameter/variables.
	E.g: 
		public void add(int c, int a){
		}
	Here: c & a are called method parameters.
	
- While declaration of method parameters, should not initilize the value for method parameters.
	E.g: public void add(int i = 20, int c) - X 
		 public void add(int i = 20, int c = 0) - X 
		 public void add(int i, int c) - ok 

2. While calling this method, we need to pass only specified type values.
	E.g:
	m1(int a, int b){}
	m1.add(10, 20); - Ok
	
	m1.add(10.0, true); - X 
	- CE: expected int,int but found double and boolean.
	
	m1.add(int a, int b); - X 
	- we should not declare variables while calling.
	
	int a = 0;
	int b = 33;
	m1.add(a, b); -- ok
	m1.add(0, 30); -- ok
	m1.sub(a, b); -- ok
	
3. Method parameter - scope
	We can access only with in the declared method.
		here: 
		public void m2(int a){
			System.out.println(a);			
		}
		
		public void m3(){
			System.out.println(a); -X //a is not declard in thi method. it is avaialbe only in m2 method.			
		}
--------------------------------------------------
Method return types:
---------------------------
public int m1(int a) {
	return 0;
}
public - access specifier/modifier
int - return type - date type is int
	- any data type is possible here.
	eg. int 
		float
		boolean
		void
		MethoOne
		
1. Each method must have a return type before the method name.
	public void m1(){}
	Here, void is the return type.
	
	public static m1(){} X//CE return type is missing.
	
2. void means, it returns nothing. so no return statment is not required in the method.
	Eg.
		public void m1(){};	Ok
		public void m1(){ return 1}; X c.e: when method return type is void we should not return any thing/value.

3. If return type is otherthan void, like int,float and all other datatypes, then must return the value.
		public void m1(){}	Ok
		public int m2(){return 1;}	Ok
		public int m3(){}	X //CE: return type is missing.
		public int m4(){return true;}	X //CE: return type is wrong.
		public int m4(){return int a;}	X //CE: return type is wrong. we should not declare
		public int m4(){return a;}	Ok 
		
4. If any method return type is otherthan void, then while calling we may store the value. storing the value is not always required.
	class A {
	
		p s v m(String[] args){
			A a = new A()
			int c = a.m2(); // when we required
			a.m2(); // when we don't want the value.
			
			//int  a =a.m1(); X 
			//int a = MethodReturnTypeExample.m1(); ce:MethodReturnTypeExample.java:10: error: incompatible types: void cannot be converted to int
			
			a.m1(); Ok
		}
		p v m1(){
			
		}
		
		p int m2(){
			return 1;
		}
	}

5. If return type is void, we should not store that to a variable in caller method.
		p v m2(){};
		int a = m2(); X//CE error: incompatible types: void cannot be converted to int
		
6. return statement should be the last line of a method. Otherwise we will get compile time error as unreachable statement.
	p int m1(){
		return 0;
		int a = 20;	- X; unreachable statement
	}
	
7. If method return type is a class name, then we should return that class object in that method.
	public static MethodReturnTypeDemo getObject(){
		MethodReturnTypeDemo m = new MethodReturnTypeDemo();
		return m;
	}

------------------------------------------------------------
Variables:
which holds/stores some value.
int i = 20;

Here:
int - datatype
a - identifier - variable name
= - operator
30 - value/literal

3 types:
--------
1. instance variables
2. static variables
3. local variables

------------------------
1. Instance variables
------------------------
 A variable which declared in side a class but outside of the methods.
 e.g: Here x is instance variable.
	class A {
		int x = 20;
		static int y = 35;
		
		p v m1(){
			int z = 30;
			System.out.println(x);
		}
		
		p s v m2(){
			//System.out.println(x); 
			//C.E: error: non-static variable x cannot be referenced from a static context
            
			A a = new A();
			System.out.println(a.x);
		}
	}
- If more than 2 or more methods uses same variable then we can declared that variable as instance variable.

- instance variables can be directly used in only instance methods.
- instance variables can't directly used in static methods.

- instance varibles are called properties.
- which properteis are specific to each object, those properties should be decalared as instance variables. e.g age, name, fatherName.

- For each object a separate copy of instance variables will be there.

- instance variables can be accessed through the object in static methods.
	p s v m2(){
		A a = new A();
		sop(a.x);
	}

- For instance varibles jvm will provide default values.
	default values for instance variable:
	primitive data types:-
		byte, char, short, int, long ==> 0
		boolean => false 
		float, double => 0.0

	String and other classes => null
---------------------------------------------	
2. Static variable
---------------------------------------------
  A variable which declared in side a class but outside of the methods which declared with static keyword.

 e.g: Here y is static variable.
	class A {
		int x = 20;
		static int y = 35;
		
		p v m1(){
			int z = 30;
		}
	}
- If more than 2 or more methods uses same variable then we can declare that variable as static variable.

- static variables can be directly used instance methods as well as static methods.
 	
- which are common to all objects, those properties should be decalared as static variables. e.g collegeName, villageName.

- For all objects only one copy of static variables will be there.
If we chage the static variable using any object, it will change to all other objects.
	s1.collegeName = "ajlj";
	sop(s2.collegeName) //it will print the above value.

- For static varibles also jvm will provide default values.
	default values for instance variable:
	primitive data types:
	byte, short, int, long ==> 0
	boolean => false 
	float, double => 0.0

	String and other classes => null

--------------------
3. Local variable:
--------------------
 A variable which declared inside a method, or method parameters called local variable.
 
 e.g: Here a and z are local variables.
	class A {
		int x = 20;	//instance
		static int y = 35; //static
		
		p v m1(int a){
			int z = 30;
		}
		
		p v m2(){
			Sop(z); //X:CE: can't find symbol z
		}
	}
- We can't access the local variables of a method in another method.
- For local variables default value shall not provide by jvm.
	p v m1(){
		int l;
		sop(l); //CE: can't initilize, jvn not providing the default value.
	}
-----------------------------------------------------  |	
variable type | instance method	  |static method         |
--------------|-------------------|--------------------|
instance var  | yes,eg: sop(a)    |no, e.g, sop(obj.a);
------------- |-------------------|--------------------|
static 	var   | yes,eg: sop(a)    |yes,eg: sop(a)
------------- |------------------|--------------------|

26-09-2018
- Getter:
- For each instance variable, we should have getter.
- getter method return type is as same as instance variable data type.
- getter should not take any method parameter.
- instance variable should be declared as private.
- getter method should return instance variable.
- getter method access specifier should be public.

	class Person{
		private String name;
		
		public String getName(){
			return name;
		}
	}

	
- Setter:
- For each instance variable, we should have setter method.
- setter method access specifier should be public.
- setter method return type is void. It should not return any value.
- setter should take one parameter and parameter data type is same as instance variable.
- instance variable should be declared as private.
- setter method should not return any value.
- When method parameter name and property name are same, then we should specify the instance variable name with this keyword. Otherwise value will not set to instance variale.

	class Person{
		private String name;
		
		public void setName(String name){
			this.name = name;
		}
	}

	
27-09-18
Constructor:
- Constructor is like a method. 
- Constructor name should be as same as class name.
- constructor should not have any return type.
- When ever we create an object for a class then immediately constructor will be executed.
- A constructor which is not having any parameter called default constructor.
	class Movie {
		public Movie(){	//default
		}
		
		public Movie(int a){	//parameterized
		}
	}
- types:
	1. default constructor:
		A constructor which does not have any parameter
		If no constructors are avaialbe in our class, then jvm will provide the default constructor.
		
			public Movie(){}
			
	2. parameterized constructor:
		A constructor which has parameters.
			public Movie(int a){}
			
			
- If we add return type to constructor, then it will be considered as a method. It is no more a constructor.
- if developer is not writing any constructor in a class then jvm will provider default constructor.
- In one class we can have more than one constructor also.
- From construcor we can call instance methods as well static methods.
- In construcor we can use 
instance variables as well static variables.


what is the use of constructor?
- To perform the initilization for the instance variables.
- If we want to call any method which has to be executed only once for object, we should call from construcor.

How many times constructor will be executed?
For each object 1 time constructor will be executed. if we create 10 objects, 10 times will be execued.

If we set value from construcor as well as from settter, which will take highest precedense?
	- Setter method value will be availabe, because it is overriding the constructor value.
	eg
		Movie m = new Movie("Sudhakar", "Suma");
		
		m.setHero("Murali");
		m.setHeroin("Kajal");
		
		op: Murali, Kajal
	
1-10-2018
- The parameter order is very important.
E.g: Movie(1, 1);
	Error: incompatible types.
	
- We can have any number of constructors in our class. But we can't have 2 constructors with same type order and same number of parameters.
	Eg : 1 - Compile time error, construcor already defined.
		
		public Movie(String fgdfgdgsdfg, String heroin){
		}
		
		public Movie(String a, String b){
		public Movie(String a, String b){
		}
	
	Eg : 2 Valid. It works
		public Movie(String fgdfgdgsdfg, String heroin){
		}
		
		public Movie(String a, int b){
		}
	
	Eg : 3 Valid. It works
		public Movie(int a, String heroin){
		}
		
		public Movie(String a, int b){
		}
		
	Eg : 4 Compile time error:Constructor already defined.
		public Movie(){
		}
		
		public Movie(){
		}
	
- One construcor can call another construcor using this(). But it should be first line in the construcor.
	E.g:1 Works fine.
		public Movie(){
			this(1);
		}
		
		public Movie(int a){
		
		}
		
	E.g:2 Compile time error: this() should first line of a construcor.
		public Movie(){
			System.out.print("Defalut");
			this(1);	//CE
		}
		
		public Movie(int a){
		
		}
	
- Recursive construcor calling is not possible in java
	E.g: Compile time error: Recursive calling of constructor.
		public Movie(){
			this(1);	
		}
		
		public Movie(int a){
			this();
		}

- Constructor overloading: 2 constructors having different  type of parameters or different number of parameter called constructor overloading.
	
	Eg : 2 Valid. It works
		public Movie(String fgdfgdgsdfg, String heroin){
		}
		
		public Movie(String a, int b){
		}
		
		public Movie(String a, int b, int c){
		}
-------------------------- Constructor example --------------------------------------------------
		class Movie {
			private String hero;
			private String heroin;
			private int shootingDays;
				
			private static int movieCount;
			
			public Movie(){
				this("b", "a");
			}
			
			public Movie(String a, String heroin){
				System.out.println("Movie constructor");
				hero = a;
				this.heroin = heroin;
				
				//we can instance as well static.
				this.init();
			}
			
			public String getHero(){
				return hero;
			}
			public void setHero(String hero){
				this.hero = hero;
			}
			
			public String getHeroin(){
				return heroin;
			}
			
			public void setHeroin(String heroin){
				this.heroin = heroin;
			}
			
			public static void main(String args[]){
				Movie m = new Movie("Sudhakar", "Suma");
				
				m.setHero("Murali");
				m.setHeroin("Kajal");
				
				Movie m1 = new Movie("Sudhakar2", "Suma3");	
				
				Movie m2 = new Movie("Sudhakar1", "Suma2");
				
				Movie m3 = new Movie("Sudhakar1", "Suma2");
				
				System.out.println(m.toString());		
				System.out.println(m1.toString());		
				System.out.println(m2.toString());
			}
			
			public void init(){
				System.out.println("taking rest");
			}
			
			public String toString(){
				return this.hero + " "+ this.heroin + " "+ this.shootingDays;
			}
		}		
----------------------------------------------------------------------------------------------

this - current class 
	- to call instnace methods and instnace variables.
	this.m1();
	this.age = age;
	
this()	- to call another constructor
	this();
	
super - super class 
	- to call instnace methods and instnace variables from super class.
	super.m1()l
	
	
super()	- to call another constructor
	super(1);
	
	
02-10-18 OOPS
-------------
- Object
- class 
- method - behivour/actions
- variables. - state/properties

Features:-
	- Data hiding
	- Encapsualation	
	- Inheritance
	- Abstraction
	- Polimorphism	

1.Data hiding:
		Declare all instance variables as private called data hiding. 
		From outside class, can't change these value.
		E.g:
		class Person {
			//hiding our instance variables.
			private int age;
			private String name;
		}
		
2. Abstraction
	Providing some service and hiding the internal implementation is called abstraction.
	E.g Atm is providing some service, we don't know it is working, means we dont know internal implementation.
		
		public void setAge(int age){}
		
3. Encapsualation:
		Data hiding + abstraction 
		E.g:
------------------------------------------------------------------------------------------
	class Person {
		//hiding our instance variables.
		private int age;
		private String name;
		
		public void setAge(int age){
			this.age = age;
		}
		
		public int getAge(){
			return age;
		}
		
		public void setName(String name){
			this.name = name;
		}
		
		public String getName(){
			return this.name;
		}
	}
	
	class PersonDemo {
		
		public static void main(String... args){
			Person p = new Person();
			p.setName("Sud");
			//p.age = 40;//invalid
			p.setAge(20);
			System.out.println(p.getName());
			System.out.println(p.getAge());
			
		}
	}
------------------------------------------------------------------------------------------
4.Inheritance
	- Acquiring parent properties and methods.
	- Code reusability.
	- Reduce the code amount
	
- Using 'extends' keyword, we can achive the inheritance.
	class A extends B {
	}
	Here B - parent
		 A - Child
		
----------------------------------------------------------------------------------
	class Parent{
		int property = 100000;
		static int cash = 1000000;
		
		public String toString(){
			return "property "+ property;
		}
	}

	class Child extends Parent {
	
	public static void main(String... args){
		Child c = new Child();
		System.out.println(c.property);
		System.out.println(c.cash);
			System.out.println(c.toString());
		}
	}
----------------------------------------------------------------------------------
Inheritance types:
1. Single Inheritance
2. Multiple Inheritance
3. Multi level Inheritance

	
1. Single Inheritance
	A class which extends only one class, it is called single inheritance.
--------------------------------------------------------
class A {
	int cash = 20;
	
	public int getCash(){
		return cash;
		}
	}
	//single inheritance
	class B extends A{
		
		String property = "5 hecres";
	}
----------------------------------------------------
2. Multiple Inheritance:
- A class which extending more than one class is called multiple inheritance.
- This is not possible in java

Why multiple inheritance is not possible in java?
If one is extending more than one class, if same method is avaiable in both parents, then compiler doesn't to which method it has call from which parent.
1
Eg: In the below C class, 	When calling c.getCash() method, getCash method is available in both parent classes, compiler doesn't from which class, it has call. that's why in java multiple inheritance is not possible.
-------------------------------------------------
class A {
	int cash = 20;
	
	public int getCash(){
		return cash;
	}
}
class B {
	int cash = 20;
	
	public int getCash(){
		return cash;
	}

}
//multiple inheritance
class C extends A, B{
	
	String property = "5 hecres";
	public static void main(){
		C c = new C();
		c.getCash();
	}
}
-------------------------------------------------
3. Multi level Inheritance
- One class having more than 1 parent ansisters called multilevel inheritance.
	A  - grand parent
	|
	B  - parent
	|
	C  - child

-----------------------------------------
class A{
}
class B extends A {
}
class C extends B{
}
-----------------------------------------
	
Object:
-------
- It is avaiable in java.lang package
- It is super class for all classes in java.
- If any class is not extending any other class, jvm will extends Object class by default.
	- 11 methods.
	notify() - 2 
	wait() - 3
	toString()
	hashCode()
	clone()
	equals()
	getClass()
	finalize()
	
== operator always check for reference comparision. Even though same content, it will return false.

public class ObjectTest {
	public static void main(String... arg){
		String s = "Test";
		String s1 = new String("Test");
		String s2 = "Test";
		
		System.out.println(s1 == s);
		System.out.println(s == s2);
		// System.out.println(s1.equals(s));
	}
}

equals() method check for content comparision.
- String and all wrapper classes are overriden.
	primitives 	- 
	byte 		Byte
	short		Short
	int 		Integer
	long		Long
	float		Float
	double		Double
	char		Character
	boolean		Boolean
- StringBuffer and StringBuilder doesn't overidding equals method.

https://docs.oracle.com/javase/8/docs/api/

Method calling in inheritance:
1. We can create object child class and refer as child class
	C object = new C();
	- Using child class reference, we can call all child class methods and all its parent class methods and variables also.

2. We can use parent class reference to hold the child class object.
	B object = new C();
	
	- When ever we holding child class object using parent class reference, we can't call the child class methods or variables using parent class reference.
	object.printMyValues(); gives error because parent class reference is hold child object.
	
3. If we want to call child class methods using parent class reference, we need to do type casting.

Type casting:
	Casting the type(Changing the type)
	B objecct = new C();
	
	C obj1 = (C) object;
	
	obj1.printMyValues();

	-----------------------------------------------------------------
	
	class A {
	int cash = 20;
	
	public int getCash(){
		return cash;
	}
}

//single inheritance
class B extends A{
	
	String property = "5 hecres";
}


class C extends B {
	public static void main(String args[]){
	
		B object = new C();
		System.out.println(object.getCash());
		System.out.println(object.hashCode());
		
		//type cast
		// A obj1 = object;
		 C obj1 = (C)object;
		obj1.printMyPropery();
		
	}
	
	public void printMyPropery(){
		System.out.println("property:"+ property);
	}
}
-----------------------------------------------------------------
overloading:-method signature: method name and method parameters
	public void m1(int a){}

m1(int a)
--------- -> method signature: method name and method parameters.
	- Return type and access specifier are not part of method signature.


Methods which have same name but with different signature.
1. same method name but different numbmer of parameters
	class OverloadingExample {
		
		public void m1(int a){
		}
		
		public void m1(){
		}
	}

2. same method name but parameter type order is different.
		class OverloadingExample {
		
		public void m1(int a){
		}
		
		public void m1(String a){
		}
	}


class OverloadingExample {
	
	public void m1(int a, String b){
		System.out.println(" int string");
	}
	
	public void m1(String a, int b){
	System.out.println(" string int");
	}
	
	public int m2(int a, String b){
		return 1;
	}
	
	public static void main(String[] args){
		OverloadingExample a = new OverloadingExample();
		a.m1(10, "10");
	}
}

Static binding:- 
Compiler knows which method to call based on the code, it is called static binding or compile time binding.

- Mehtod overloading is early bindng or compile time binding or static binding.

- We can achive the same funtionality.
- we can increase the readability.
- In single class we can achive overloading.


Overriding:
----------
- When we are not satisfied with the super class method implementation, we should go for overidding.

- With same method name, same return type and same access specifier in the child class as same as parent class is called overriding.

- In a single class we can't achive overidding.

------------------------------------------------------
class Parent {
	int cash = 200000;
	
	public void marry(){
		System.out.println("marry subbalaxi");
	}
	
}

class Child extends Parent{

	public static void main(String args[]){
		Child c = new Child();
		System.out.println(c.cash);
		c.marry();		
	}
		
	public void marry(){
		System.out.println("I want to maryy Tamanna");
	}	
}
------------------------------------------------------
- Even though we are holding a Child class object with parent class reference, overidding method will be called always.
------------------------------------------------
class Parent {
	int cash = 200000;
	
	public void marry(){
		System.out.println("marry subbalaxi");
	}
	
}

class Child extends Parent{

	public static void main(String args[]){
		Parent c = new Child();
		System.out.println(c.cash);
		c.marry();		
	}
		
	public void marry(){
		System.out.println("I want to maryy Tamanna");
	}	
}
--------------------------------------------------

Runtime Binding:
When override any methods, compiler doesn't know to which method it has call, so JVM will identify that in runtime, so it called Runtime Binding.
- overriding is runtime binding example.

- final methods we can't override.
-------------------------------------------
	E.g:
	class Parent {
	int cash = 200000;
	
	public final void marry(){
		System.out.println("marry subbalaxi");
	}
	 
}

class Child extends Parent{

	public static void main(String args[]){
		Parent c = new Child();
		System.out.println(c.cash);
		c.marry();		
	}	
}
----------------------
- for private methods overidding is not possible.

- While overidding, we can increase access specfier scope but we should not decrease it's scope.

access specfier order
public > procted > default > private

working eg: Here we are increasing access specfier scope in child,
---------------------------
class P {
	void m1(){}
}
class C {
	void m1(){}
	
	//or
	procted void m1(){}
	
	//or
	public void m1(){}
}
---------------------------
	
Not	working eg: Here we are decreasing access specfier scope in child
---------------------------
class P {
	public void m1(){}
}
class C {
	void m1(){}
	procted int m1(){}
}
---------------------------
Differencs between Overriding and Overloading
------------------------------------------------------------------------------------
points						Overridig					Overloading
------------------------------------------------------------------------------------
1. Method signature			should be same				method signature should be different.
2. can we change return		can't change return type 	can change return type.

3. Can we change acces		We can the access specific 	we can change
	specifier				but we should increase.
	
4. Single class				No, we need inheritance		Yes,it is possible.

5. Binding 					Runtime binding				Static Binding

------------------------------------------------------------------------------------
Polymorphism:-
- Same object is behavihing differently at differnt times.

-----------------------------------------------------
class Parent {
	int cash = 200000;
	
	void marry(){
		System.out.println("marry subbalaxi");
	}
	
}


class Child2 extends Parent {

}


class Child extends Parent{

	public static void main(String args[]){
		Parent c = new Child();
		System.out.println(c.cash);
		c.marry();
		
		Parent p = new Child2();
		System.out.println(p.cash);
		p.marry();
		
		p = new Child();
		System.out.println(p.cash);
		p.marry();
				
		int a = 20;
		System.out.println(a);
		
		a = a + 5;
		a = a + 15;
		System.out.println(a);
	}
		
	protected void marry(){
		System.out.println("I want to maryy Tamanna");
	}	
}
-----------------------------------------------------
- We can achive abstraction. 

14-10-2018
Typecasting:
-----------

Casting the one type data to another.
--------------------
Eg:
class TypeCasting {
	public static void main(String[] args){
		int a = 1;
		byte b = (byte)a;
		
		System.out.println(a);
		
		TypeCasting c = new TypeCasting();
		
		A obj = new B();
		c.display(obj);
		
	}
	
	public void display(A a){
		System.out.println(a);
	}
}

E.g:
class TypeCasting {
	public static void main(String[] args){
		TypeCasting t = new TypeCasting();
		
		A a = new B();
		a.m1();
		
		B b = (B) a;
		b.m2();	//ce
		
		A a1 = new C();
		C c = (C) a1;
		
		a1.m1();
		c.m3(); //ce
		
		A a3 = new A();
		a3.m1();
	}
}

class A {
	public void m1(){
		System.out.println("m1");
	}
}

class B extends A {
	public void m2(){
		System.out.println("m2");
	}
}

class C extends A {
	public void m3(){
		Sys tem.out.println("m3");
	}
}
-------------------------
	A a = new B();
	B b = (B) a;
	
1 - B - class/interface
2 - b - reference variable/ object reference
3 - B - class/interface
4 - a - reference variable/object reference

Compiler rules:
1. Is there a relationship between 3 & 4. Either parent to child or child to parent. Otherwise it gives a compile time error

2. 3rd should be either same type or its child of 1st.
	As per example, B should be same as B or its child.
 ---------------------------------
 		A a = new B();
		a.m1();
		
		B b = (A) a;
 ---------------------------------
 
Runtime rules
3. 3rd type and 4th type object should be same. Otherwise we will get ClassCastException.

------------------------------
		A a = new B();
		a.m1();
		
		B b = (B) a;
		// B b = (A) a;
		
		b.m2();
		
		A a1 = new C();
		C c = (C) a;	//RE: CCE
		
------------------------------
instanceof:
- To avoid the ClassCastException, we should use 'instanceof' keyword.
- instanceof returns true only when reference is not null and object type is same.
- To use the instanceof operator, there should be relation either parent to child or child to parent.
Case 1:		
		A a1 = new C();
		
		//a1 = null;
		if(a1 instanceof C){
		}

	Here:	
		a1 instanceof C	returns true. Because a1 object is C.

Case 2:		
		A a1 = new B();
		
		//a1 = null;
		if(a1 instanceof C){
		}

	Here:	
		a1 instanceof C	returns false. Because a1 object is B.
Case 3:		
		A a1 = null;
		if(a1 instanceof C){
		}

	Here:
		a1 instanceof C	returns false. Because a1 is null.
Note: null is not any type.
	
Case 4:		
		C c = new C();
		if(c instanceof A){
		}

	Here:	
		c instanceof A - returns true. Because c is child of A
		
Case 5:		
		A a= new A();
		if(a instanceof C){
		}

	Here:	
		c instanceof A - returns false. Because a is not child of C. 
		
		
Summary:
	x intanceof y
	x - object reference
	y - Class/interface name
	
		true	
			- x and y should be same
			- x is child and y is parent
		false
			- x is null
			- x is parent and y is child 
	
-----------------------------------------------------------------------------------------
Pojo: Plain Old Java Object:
	- Only instance variables
	- only setter and getters will avaiable.
	- constructor.
	
-----------------------------------------------------------------------------------
	class Person {
		//hiding our instance variables.
		private int age;
		private String name;
		
		public void setAge(int age){
			this.age = age;
		}
		
		public int getAge(){
			return age;
		}
		
		public void setName(String name){
			this.name = name;
		}
		
		public String getName(){
			return this.name;
		}
	}
------------------------------------------------------------------------
16-10-2018
interface:
- Interface also like a class. It has methods and static variables.
- interface should not have construcors, blocks and instance varaibles.
- we can't create objects for interfaces. so instance variables are not allowed.
- untill java 1.7 static methods should not write interfaces.

- all variables in interface are "public static final". If developer is not adding them, compiler will add these for all variables in interface.

- Final variables must be initilized.
	public static final int personalLoanRate; //CE: must be init
	public static final int personalLoanRate = 20; //Ok

- final variables can't be changed.
- final variables can be accessed through class.variablename

- in interface, only public access modifier is allowed for variable. private and protected are not allowed. 
-----------------------------------------------------
interface Loan {
	public static final int carLoanRate = 15;
	int peronalLoanRate = 20;
	static int houseLoanRate = 25;
	//private static int houseLoanRate = 25; //CE
	//protected static int houseLoanRate = 25; //CE
}


class LoanTest {
	static int a;
	public static void main(String[] args){
		LoanTest.a = 25;
		// Loan.peronalLoanRate = 30;
		System.out.println(Loan.carLoanRate);
		System.out.println(Loan.peronalLoanRate);
		System.out.println(LoanTest.a);
	}
	
	
}
----------------------------------------------------------
abstract methods:
 - A method which doesn't have any body is called abstract methods.
 - by using 'abstract' keyword in the method, we can abstract method.
 
- By default all methods in interface are abstract methods.

- If developer explicitly declared method abstract then compiler will not add.
- if developer is not adding 'public abstract', then compiler will add them for each method.
- private and protected are not allowed for methods in interface.

- By using 'implements' keyword , A class can implement an interface.
E.g:

	interface Loan {}
	class PLoan extends Loan {} //CE
	class PLoan implements Loan {} //OK
	
- If any class is implementing an interface, then that class must provide the implementation (body for methods) for all abstrct methods.otherwise we will get comile time error.

--------------------------------------
interface Loan {
	public static final int carLoanRate = 15;
	int peronalLoanRate = 20;
	static int houseLoanRate = 25;
	
	void calculateIntrest();
	public abstract void calculatePersonalIntrest();
}

class PersonalLoan implements Loan{

	public void calculateIntrest(){
		System.out.println("Calcaulate intrest");
	}
	
	public void calculatePersonalIntrest(){
		System.out.println("Calcaulate personal intrest");
	}
}

class LoanTest {
	static int a;
	public static void main(String[] args){
		LoanTest.a = 25;
		// Loan.peronalLoanRate = 30;
		System.out.println(Loan.carLoanRate);
		System.out.println(Loan.peronalLoanRate);
		System.out.println(LoanTest.a);
		
		Loan p = new PersonalLoan();
		p.calculateIntrest();
		p.calculatePersonalIntrest();
		
	}
}
-------------------------------------
25-10-2018 Abstract classes

- A class which is declared with abstract keyword.
- abstract keyword can be used only to methods and classes but not for variables.
- abstract keyword should be before class keyword.
- for abstract classes we can't create a object.
- If atleast one abstract method is there in a class then that class must be declared as abstract class. otherwise we will get compile time error.
- We can have any number of concreate methods and abstract methods.
- even if there is no abstract method in a class still we can declare that class as abstract.
-----------------------------------
abstract class AbstractExample {
	
	public void m1(){
		System.out.println("m1");
	}

}
-----------------------------------

methods:-
1. concreate methods
	A method which has method body.
2. abstract methods
	A method which doesn't have a body.
	
- When ever we are extending any abstract class, then child class must provide the body for all parent class abstract methods. otherwise we have to declare child class as abstract. 
- In abstract class we can have instance variables, static variables, instance methods, static method and constructors.
----------------------------------------------------
abstract class AbstractExample {
	int a = 20;
	
	public abstract void calculateIntrest();
	public void m1(){
		System.out.println("m1");
	}

}

class AbChild extends AbstractExample {
	public void calculateIntrest(){
		System.out.println("child cal");
	}
}


class AbstractDemo {
	public static void main(String[] args){
		AbstractExample a = new AbChild();
		a.calculateIntrest();
		System.out.println(a);
		
	}
}
----------------------------------------------------


interface -> interface => extends
-------------------------
interface A {
}
interface B extends A {
}
---------------------------

class => class => extends
-------------------------
class A {
}
class B extends A {
}
---------------------------


interface => childClass => implements
-------------------------
class A {
}
class B implements A {
}
---------------------------

class => interface ==> This is not possible in java
-------------------------
class A {
}
interface B extends A {
}
---------------------------

- One class can implement any number of interface at same time. So we can achive multiple inheritance through interfaces.

Question: how multiple inheritance is possible in java?
Yes, multiple inheritance is possible only through the interfaces but not with classes.

--------------------------------------------------------------
interface A {
	void m1();
	
}

interface B {
	void m1();
}

class C implements A, B {
	public void m1(){
		System.out.println("c m1");
	}
}

class InterfaceTest {
	public static void main(String[] b){
		A a = new C();
		a.m1();
		
		B b = new C();
		b.m1();
		
		C c = new C();
		c.m1();
		
	}
}
--------------------------------------------------------------
final:
------
final is a keyword. it can be used for below 
1. variables
2. methods
3. classes

Final variables
- Final variables must be initilized.
	final int a =10; //OK
	final int b; //CE
	
- final variables can't be changed.
	final int a = 20;
	a = 50; //CE:
	
Final metods:
- final methods we can't override.
-------------------------------------------
	E.g:
	class Parent {
	int cash = 200000;
	
	public final void marry(){
		System.out.println("marry subbalaxi");
	}
	 
}

class Child extends Parent{

	public static void main(String args[]){
		Parent c = new Child();
		System.out.println(c.cash);
		c.marry();		
	}	
}
------------------------------------------
Final class
- Final classes we can't extend.
------------------------------
final class Parent {
	public void cal(){
		System.out.println("Subbamma");
	}
	
}

class Child extends Parent {
public void marry(){
		
	}
}

- We can't use final keyword with abstract keyword. Where abstract refers inheritance and final refers no inheritance.

abstract final class A {
}	//CE
------------------------------

Packages:
--------
https://www.javatpoint.com/package
What is package?
- package is a group of classes or interfaces.


Why we should use package? 
- For easy maintainance
- readability
- we can avoid name collusion.

- It should 1st statement.
- package name should be like this: com.companyname.packagename 
	com.ss.math;
	
Compilation:
Without package:
	javac A.java
	
With package
	javac -d . A.java
	javac -d b A.java
	javac 	- javac compiler
	-d 		- directroy (destination folder)
	. 		- current folder
	b 		- folder name
	
Running:
Without package:
	java A
	
With package
	java com.ss.pack.A
	java 	- To call the jvm to execute our program

package types:
1. Built in packages
	The already defined packages in java
		java.lang
		java.math
		java.utils
		java.io
	
2. user defined packages:
	- packages which are created by us.
	
	
	
import:
-------
-To use from other package classes in our class, we have to import that class first.
- compiler tries to check the class is available in current package, if it is not avaibabl,it gives compiler time error.
- import statement specifies to compiler to check the class in other package.
- import should be after package statement.

Order: order of apperance
	pacage
		|
	import
		|
	class
	
- If any class is public, then file name should be same.
- In one file, only class can declare as public

absolute class name:
a class name with package name	
	com.ss.pack1.StringUtil

There are three ways to access the package from outside the package.

1. import package.*;
	- All classes will imported.
	
2. import package.classname;
	- Only specified class will be imported.
	
3. fully qualified name.
	- Only specified class.
----------------------------------------------------------------
30-10-2018	
Access modifier/specfier: Which specify the access from other classes.
1. public 
2. protected
3. default
4. private

1. public 
	We can access from anywhere
	
2. protected
	We can access with in the class, with in the curret package  and with in the child classes from outside package.
	
3. default
	We can access with in the class and with in the curret package (folder).

4. private
	Only with in th2e class. From outside class can't call private methods.

------------------------------------------------------------
package com.ss.pack;

public class A {
	public static void main(String[] a){
		System.out.println("Hello package");
		a1();
		a2();
	}
	
	
	private static void a1(){
		System.out.println("a1 private method");
	}
	
	static void a2(){
		System.out.println("a2 default method");
	}

	protected static void a3(){
		System.out.println("a2 public method");
	}
	
	public static void a4(){
		System.out.println("a2 public method");
	}
}



package com.ss.pack;

import com.ss.pack1.MathUtil;
// import com.ss.pack1.*;

class B {
	public static void main(String[] a){
		System.out.println("Hello package B");
		
		int val = MathUtil.squre(10);
		System.out.println(val);
		
		int val1 = com.ss.pack1.StringUtil.squre(10);
		System.out.println(val1);
		
		//A.a1();
		A.a2();
		A.a3();
	}
}


package com.ss.pack1;
import com.ss.pack.A;

public class C extends A{
	public static void main(String[] a){
		System.out.println("Hello package C");
		//A.a2(); can't call because it default.
		//A.a3();
		
		C c = new C();
		// d.a1();
		// d.a2();
		c.a3();//C is child of A
		c.a4();
		
	}
}

class D{
	public static void main(String[] a){
		System.out.println("Hello package C");
		//A.a2(); can't call because it default.
		//A.a3();
		
		D d = new D();
		// d.a1();
		// d.a2();
		d.a3();//CE: D is not a child of A
		d.a4();
		
	}
}
------------------------------------------------------------
Class:
- For class only applicable modifier are:
	1 - public 
	2 - default 
	3 - static 
	4 - abstract
	5 - final 
	
	public class A{}	//OK
	protected class A{} //CE
	public abstract class A{}	//OK
	public abstract final class A{}	//CE abstract and final combination wrong.
	
-------------------------------------------------------------
31-10-208
java lang package:
https://docs.oracle.com/javase/8/docs/api/index.html?java/lang/package-summary.html

interfaces:
	Appendable
	AutoCloseable
	CharSequence
	Cloneable
	Comparable
	Iterable
	Runnable

Classes:
	Boolean
	Byte
	Character
	Class
	Double
	Enum
	Float
	Integer
	Long
	Math
	Number
	Object
	Runtime
	Short
	String
	StringBuffer
	StringBuilder
	System
	Thread
	ThreadGroup
	ThreadLocal
	Throwable
	Void
	
	
1. String
2. StringBuffer - 1.0
3. StringBuilder - 1.5
4. Object
5. Math

----------------------------
Math	
	1. min
	2. max
	3. abs
	4. random
	5. round
	6. ceil
	7. floor
	
	
String
- String is a final class. So we can't extend String class.
- String is a immutability class.
- It is not a thread safe. 
- equals method override.

What is immutability?
When ever we are trying to change anything in the object, it will create a new object with modifications. The existing object will not change.
	E.g:
		String s = "Sudha";
		
	When we are calling concat method, it will create a new string as 'sudhakar' but in the s it will not change.
		s.concat("kar");

	If we want to hold the changed object then 
	s = s.concat("kar");
	
Constructors:
	String()
	String(char[] a)
	String(String s)
	String(StringBuffer buffer)
	String(StringBuilder builder)

Methods:
	1. length(): return no of characters
	2. isEmpty(): true/false 
	3. contains()
	4. concat();
	5. 

how to instantiate string?
String a = "Sudha";
String b = new String("Sudhakar");

a.isEmpty();	//false
------------------------------------
class StringTest {

	public static void main(String[] args){
		String s = "Sudha"; 
		System.out.println(s);
		
		s = s.concat("kar");
		System.out.println(s);
		
		int index = s.indexOf("b");
		if(index != -1){
			System.out.println("available "+ index);
		}else{
			System.out.println("not available" + index);
		}
		
		boolean b = s.contains("k");
		System.out.println(b);
		
		char c = s.charAt(3);
		System.out.println(c);
		
		int compare = s.compareTo("Sudhakar1");
		System.out.println(compare);
		
		boolean eq = s.equals("sudhakar");
		System.out.println(eq);
		
		eq = s.equalsIgnoreCase("sudhakar");
		System.out.println(eq);
		
		boolean startWith = s.startsWith("Su");
		System.out.println(startWith);
		
		boolean endsWith = s.endsWith("Su");
		 System.out.println(endsWith);
		
		s = s.replace("kar", "Badugu");
		System.out.println(s);
		
		String name = " Murali ";
		System.out.println(name.trim());
		System.out.println(name.toUpperCase());
		System.out.println(name.toLowerCase());
		
		char[] chArray = name.toCharArray();
		for(int i=0 ;i<chArray.length; i++){
			System.out.println(chArray[i]);
		}
		
		StringBuffer sb = new StringBuffer(name);
		boolean res = name.contentEquals(sb);
		System.out.println(res);
		System.out.println(name.hashCode());
		
		String village = "karuru yes ra";
		System.out.println(village.indexOf('r', 6));
		System.out.println(village.lastIndexOf('r'));
		System.out.println(village.substring(0, 5));
		System.out.println(village.substring(5));
		
		String names = "ram,sham,mam";
		System.out.println(names);
		
		String[] nameArr = names.split(",");
		for(String s1 : nameArr){
			System.out.println(s1);
		}
		
		// String[] s2Arr = s.split("");
		// int count = 0;
		// for(String s3: s2Arr){
			// if("a".equalsIgnoreCase(s3)){
				// count++;
			// }
		// }
		char[] s2Arr = s.toCharArray();
		int count = 0;
		for(char s3: s2Arr){
			if('a' == s3){
				count++;
			}
		}
		
		// for(int i=s2Arr.length - 1; i>=0 ; i--){
			// System.out.println(s2Arr[i]);
		// }
		
		
		for(int i=s.length() - 1; i>=0 ; i--){
			System.out.println(s.charAt(i));
		}
		
		System.out.println(count);
	}
}
----------------------------------------------
StringBuffer
- It is not a immutability/mutabile class.
- It is a thread safe. Will cause performance problem.
- reverse()
- equals method doesn't override.

class StringBufferTest {

	public static void main(String[] args){
		StringBuffer s = new StringBuffer("Sudha"); 
		s.append("kar");
		System.out.println(s.toString());
		
		
	}
}


---------------------------------------------
StringBuilder
- It is a mutabile class.
- It is not a thread safe. 
- Improves the performance
- reverse() method available.
- equals method doesn't override.

class StringBuilderTest {

	public static void main(String[] args){
		StringBuilder s = new StringBuilder("Sudha"); 
		s.append("kar");
		System.out.println(s.toString());
		
		
	}
}

-----------------------------------------------------------
Wrapper classes:

- for primitives no methods are avaiable. to create objects, we have wrapper classes. To achieve OOPS concepts.

- String and all wrapper classes are equals() overriden.
- String and all wrapper classes are toString() overriden.
	primitives 	- Wrapper class
	byte 		Byte
	short		Short
	int 		Integer
	long		Long
	float		Float
	double		Double
	char		Character
	boolean		Boolean

main methods:
1. parseXxx	- string to number
2. toString - number to string
3. xxxValue	- wrapper to primitives
4. valueOf	- primitive to wrapper

- how to create wrapper object
	Byte(String x);
	Short(String x);
	Long(String x);
	Double(String x);

- how to convert string to number
	1. By using construcor
		String s1 = "10";
		Short s = new Short(s1);
		
		
	2. By using parseXxx() methods
		Integer.parseInt(s1);
		Float.parseFloat(s1);

- If parseXxx method not able to convert the string to number then exception will occur: NumberFormatException

- how to convert number to string - toString
		Integer i = 26;
		String is = i.toString();
		
		
- how to convert one value type to another value. eg. int to float or float to long
	xxxValue() - Wrapper to primitive
	- byteValue()
	- shortValue()
	- intValue()
	- LongValue()
	- floatValue()
	- DoubleValue()
	

- Primitive to wrapper 
	valueOf(primitiveValue)
	

public class WrapperTest {
	public static void main(String... arg){
		WrapperTest.stringToNumber();
		
		// int i = 20;
		int i1 = 25;
		
		//convert number to string
		Integer i = 26;
		String is = i.toString();
		System.out.println(is.contains("5"));
		
		//convert one datatype to another xxValue
		byte b = i.byteValue();
		
		Integer ig = Integer.valueOf(i);
		System.out.println(ig);
		
	}
	
	private static void stringToNumber(){
		int i = 20;
		Integer i1 = 20;
		Integer i2 = new Integer(130);
		Integer i3 = 130;
		
		System.out.println(i2 == i3);
		System.out.println(i2.equals(i3));
		
		String s = "10";
		String s1 = "20";
		
		//
		Integer i4 = new Integer(s);
		Integer i5 = new Integer(s);
		
		//alwasys recomened to use parseInt
		int i6 = Integer.parseInt(s);
		int i7 = Integer.parseInt(s1);
		
		System.out.println(i4 + i5);
		System.out.println(i5 + i6);
		
		String s2 = "10.23";
		// Double d = new Double(s2);
		Double d = Double.parseDouble(s2);
		int val = d.intValue();
		System.out.println(d+10);
	}
}


-----------------------------------------------------------
Exception handling:
------------------
- Exceptions occur at runtime. 
- In run time, an unexpected event which stops our program execution is called exception.
- abnormal termination of a program called exception.
- handling the exception is called exception handling.
- Exception must be a child of Throwable class.

- key words
	1. try
	2. catch
	3. finally
	4. throw
	5. throws

- Inside try block, we should write risky code.
- Always try and catch blocks both should be there. 
- try alone or catch alone is wrong.
	try{	//CE
	
	}
	
	catch(){}//ce
	catch(Exception e){}//ce
- finally is optional.
- we can have any number of try/catch blocks.
- Only when exception occurred in try block then only catch will execute.
- When there are no exception inside the try block, then catch will never execue.
- There should not be any lines between try and catch blocks.
	try{
	}
	Sop("hi");		//CE
	catch(Exception e){}
	
syntax1:
try {
	//risky code
} catch(Exception e) {

}
finally {
	//optional
}	

syntax2:
try {

} catch(Exception e) {

}
	
-----------------------------------------
class ExceptionTest {
	public static void main(String... ar){
		int i = 10;
		int b = 0;

		try{
			int c = i/b;
			System.out.println("First");	
		} catch(Exception e){
			System.out.println("error handled 1 " + e);
		}
		
		try{
			int c = i/1;
			System.out.println("Second");	
		} catch(Exception e){
			System.out.println("error handled 2" + e);
		}
		
		System.out.println("transfer to youth");	
	}
}
---------------------------------------------------------
Exception in thread "main" java.lang.ArithmeticException: / by zero
        at ExceptionTest.main(ExceptionTest.java:5)
E.g:

hierarchy:
- Throwable is root exception.
	
					   Throwable
					   -----------		
			\\\\\\\\			\\\\\
		Exception					Error
			|
		RuntimeException
			|
		ArithmeticException


1. Exception
2. ArithmeticException
2. NumberFormatException
3. ArrayIndexOutOfBoundsexception
4. StringIndexOutOfBoundsException



throw:
-----
- throw should be used to rise an exception.
- throw is a keyword.
- throw should always throw a Throwable object or it's child objects.
	eg: throw new RuntimeException();
	eg: throw new Exception();

- If throw keyword throws a any class object which is not a child Throwable then compiler will give the following error.
	e.g: throw new ExceptionThrowTest();
	
ExceptionThrowTest.java:16: error: incompatible types: ExceptionThrowTest cannot be converted to Throwable
                        throw new ExceptionThrowTest();
						
- throw should in a last line. means: after throw statement no other statements are allowed. Compiler will give error 
			throw new RuntimeException("Lessthan 18 is not allowed");
			System.out.println("exception raised");	//CE
			
ExceptionThrowTest.java:23: error: unreachable statement
                        System.out.println("exception raised");
						
						
						
Exception types:
1. checked exception
2. unchecked exception

1. checked exception:
---------------------
- Exceptions which are checked by compiler at compile time called checked exceptions.
	E.g: IOException
	
- What are the checked exception?
- Which are direct child of Exception but not RuntimeException and its child.
	Exception
	 - SQLException
	 - IOException
	    - FileNotFoundException
	 
	 
- Always checked exception must be handled in try/catch block. otherwise compile time error occurs.
CheckedExceptionTest.java:11: error: unreported exception FileNotFoundException; must be caught or declared to be thrown
                                throw new FileNotFoundException("File is not available");
-----------------------------------------CE program---------
import java.io.*;

class CheckedExceptionTest {
	public static void main(String... ar){

	
		// try{			
			System.out.println("hello");
			String file = null;
			if(file == null){
				throw new FileNotFoundException("File is not available");
			}
		// }
		// catch(IOException e){
			// System.out.println(e);
		// }
	}	
}
-----------------------------------------CE program---------

------------------------------------Working program ---------
import java.io.*;

class CheckedExceptionTest {
	public static void main(String... ar){

	
		try{			
			System.out.println("hello");
			String file = null;
			if(file == null){
				throw new FileNotFoundException("File is not available");
				// throw new RuntimeException("File is not available");
			}
		}
		catch(IOException e){
			System.out.println(e);
		}
	}	
}
------------------------------------Working program ---------
								

- a checked exception should not handle if try never throws that exception. else compile time below error occurs.

D:\Java\CoreJavaTutoral\programs\exceptions>javac CheckedExceptionTest.java
CheckedExceptionTest.java:11: error: exception SQLException is never thrown in body of corresponding try statement
                catch(java.sql.SQLException e){
				
-------------------------CE---------------------
import java.io.IOException;

class CheckedExceptionTest {
	public static void main(String... ar){

	
		try{			
			System.out.println("hello");
		}
		catch(java.sql.SQLException e){

		}
	}
	
	static void checkNumber(int num){
		if(num < 10){
			throw new RuntimeException("number lesstan 10");
		}
	}	
}				
--------------------------CE--------------------				

2. unchecked exception:
---------------------
- Exceptions which are not checked by compiler at compile time called unchecked exceptions.
	E.g: RuntimeException
	
RuntimeException and all its childs called unchecked exception.

- for unchecked exception try and catch are optional. If we want to handle these we can write try/catch.
-------------------------------------------
import java.io.*;

class CheckedExceptionTest {
	public static void main(String... ar){			
			System.out.println("hello");
			String file = null;
			if(file == null){
				throw new RuntimeException("File is not available");
			}
		
	}	
}
--------------------------------------------

throws:
-------
- throws mainly used for checked Exceptions.
- throws should be used when we are not handling the checked exception and inform caller method to handle this.
- throws followed by Exception class name.
	e.g:	throws FileNotFoundException
- throws should in the last of method signature.
		void m1() throws FileNotFoundException {} 
		void m1 throws FileNotFoundException () {} //CE
		void m1() throws new FileNotFoundException() {} //CE
- when we are throws, try is optional.

-------------------------------------
import java.io.*;

class ThrowsExceptionTest {
	public static void main(String... ar) {
		try{
			m2();
		}catch(FileNotFoundException e){
			System.out.println(e);
		}
		
		System.out.println("transfer");
	}

	static void m2() throws FileNotFoundException{
		System.out.println("m2");
		m1();
	}
	static void m1() throws FileNotFoundException{
		System.out.println("m1");
		String file = null;
		if(file == null){
			throw new FileNotFoundException("File is not available");
		}
	}
	
	
}
-----------------------------------------------------------


finally:
-------
- if we want to execute some code regardless of whether exception is raised or not, then we should add that code in finally block.
- finally will be executed always.
- finally should after catch statement.

import java.io.*;

class FinallyTest {
	int i = 10;
	public static void main(String... ar) {
		System.out.println("register");
		try{
			// FinallyTest s = new FinallyTest();			
			FinallyTest s = null;			
			System.out.println(s.i);
			
		}catch(NullPointerException e){
			System.out.println(e);	
		}
		finally {
			System.out.println("transfer");
		}
	}	
}
----------------------------------------------------------------
try with different catch blocks
----------------------------------
- one try, we can multiple catch blocks. finally is optional.
- only one finally block should be there.
	try{
		int i = 10;
		i /0;
	}
	catch(NumberFormatException nfe){
	}
	catch(ArithmeticException ar){
	}

class MultipleCatchTest{
	
	public static void main(String... ar) {
		try{
			String s = "10";
			int b = Integer.parseInt(s) /1;
		}
		catch(NumberFormatException nfe){
			System.out.println("Error" + nfe.getMessage());
		}
		catch(ArithmeticException are){
			System.out.println("Error" + ar.getMessage());
		}
		finally{
			System.out.println("Finally");
		}	//only finally
		
		System.out.println("multiple catches");
	}	
}

try with different catch order
-----------------------------
- catch order is very important.
- catch order should be child --> parent

class CatchOrderTest{
	
	public static void main(String... ar) {
		try{
			String s = "10";
			int b = Integer.parseInt(s) /1;
		}
		catch(Exception nfe){
			System.out.println("Error in exception catch");
		}
		catch(Throwable are){
			System.out.println("Error in run catch");
		}
		finally{
			System.out.println("Finally");
		}	//only finally
		
		System.out.println("catches order");
	}	
}
-------------------------------------------------------

- if we write parent exception in first catch and child in second catch, compile time errror will occur. already parent catched the exception and child catch will not executed because of that compile will give error.
------------------Wrong example ------------
class CatchOrderTest{
	
	public static void main(String... ar) {
		try{
			String s = "10";
			int b = Integer.parseInt(s) /1;
		}
		catch(Exception nfe){
			System.out.println("Error in exception catch");
		}
		catch(RuntimeException are){
			System.out.println("Error in run catch");
		}
		finally{
			System.out.println("Finally");
		}	//only finally
		
		System.out.println("catches order");
	}	
}
---------------------------------------
try with finally without catch
------------------
- finally should be there with try block.
possible scenarios:
	1. try, catch 
	2. try, finally
	3. try, catch, catch, finally
	
Not possible scenarios. Compile time error will occur.
	4. try --> CE
	4. catch --> CE
	4. finally --> CE
	4. catch, finally --> CE

class TryWithFinally{
	
	public static void main(String... ar) {
		try{
			String s = "10";
			int b = Integer.parseInt(s) /1;
		}
		finally{
			System.out.println("Finally");
		}	//only finally
		
		System.out.println("Only with finally block");
	}	
}
-------------------------------------------------------
User defined exception:
-------------
- custom exception.
- Our own exeptions, which exception classes are created by user called user defined exception.

Steps:-
1. create a class with default and parameterized construcor.
2. extend this class to any child of Throwable. eg: RuntimeException
3. To print the reason, in parameterized construcor, call super class construcor with reason.
4. Always exception class names should be end with Exception. This is not a rule. It gives more readability.
 
Note:- 
	1. If our class extends RuntimeException, then our class is unchecked exception. so no need to maintain try,catch/throws keyw
	2. If our class extends Exception, then our class is checked exception. so need to maintain try,catch/throws keyword

	
----------------------------------------
class UserDefinedExceptionTest {
	public static void main(String... ar){
		int age = 25;
		
		if(isElible(age)){
			System.out.println("transfer to youth " + age);	
		}
		
		try{
			int age1 = 20;
			if(isElible(age1)){
				System.out.println("transfer to youth "+ age1);	
			}
		}catch(UserValidationException uve){
			System.out.println(uve);
		}
	

		int age2 = 30;
		if(isElible(age2)){
			System.out.println("transfer to youth "+ age2);	
		}

		
		System.out.println("For all transferred");	
	}
	
	private static boolean isElible(int age){
		if(age >= 22 && age <= 35){
			return true;
		}
		
		throw new UserValidationException("He is not eligle by age "+ age);
	}	
}

public class UserValidationException extends RuntimeException{

	public UserValidationException(){
	}
	
	public UserValidationException(String reason){
		super(reason);//we are calling super class constructor.	
	}	
}	
-----------------------------------------
https://www.javatpoint.com/exception-handling-in-java

Collections:-
-----------
Arrays :-

- We can store Objects as well as primitives datatypes(byte, short, int, long, char, boolean, float and double) in array.

drawbacks:-
- Array is size fixed, once we create, we can't increase or decrease it's size.
- Array doesn't provide any implementation methods for dynamic size addition/remove.
- We can't store heterogenious (different types) data. e.g: we can't store string and int in a single array.
	int[] rollno = {123, 34, "Sudhakar"}; 

------------------------------------------------------------------------------------
29-01-2019	
Collection frameworks:-
---------------------

- If we want to store multiple elements to a single object, then we should go for Collection.
- collection framework is avaiable in java.util package.

Advantages:-
- We can any number of elements dynamically. Size is growable.
- Collection frameworks supports inbuilt methods for dynamic purpose.
- We can store heterogenious (different types ) data in Collection.

drawbacks:-
- We can store only Objects to collections but not primitives datatypes(byte, short, int, long, char, boolean, float and double) upto 1.5 version.

Collection frameworks api:-

									Iterable	(interface)
									   |
									Collection	(interface)
									   |
				--------------------------------------------------------------
				|							|								|			
				List					    Set								Queue		(interface)
	------------------------------   -------------------------------  ------------------------- (class)
    - ArrayList							- HashSet						- ArrayDeque
    - LinkedList						- LinkedHashSet					- LinkedList
	- Vector							- TreeSet						- PriorityQueue
	- Stack								- EnumSet						- ArrayBlockingQueue
		
		
---------------------------------------------------------------------------------------------------------

Collection:-
- A collection represents a group of objects, known as its elements
- Collection interface has common methods which are required for all sub classes.
	1. add
	2. addAll
	3. contains
	4. isEmpty
	5. remove
	6. clear
	7. removeAll
	8. toArray
	
	
1. List
-------
- Allow duplicates in collection.
- Store elements in give order. Order is important.
- null values are allowed.
1. ArrayList:-
-------------
- ArrayList allows dupliate elements in the list.
- ArrayList preserves order. Store elements in give order. Order is important.
- ArrayList implements RandomAccess, Cloneable and Serializable
- Arraylist is faster in iteration because of RandomAccess.
- Algorithm supported by Growable Array
- Default size in arraylist is 10
- ArrayList is index based.
- ArrayList is not synchronized. It is not thread safe and faster.

Drawback:-
- arraylist is slower in adding elements. Internally ArrayList creates an Array and once it is filled, it will create a new arary and copy elements from old array. Because of this reason it is slow

RandomAccess:-
-----------
- It is a marker interface. 
- A interface which doesn't have any methods and gives some addditional ability to our class called marker interface.
- Marker interface used by List implementations to indicate that they support fast (generally constant time) random access. The primary purpose of this interface is to allow generic algorithms to alter their behavior to provide good performance when applied to either random or sequential access lists.



----------------------------------------------
import java.util.*;

public class ArrayListDemo {
	public static void main(String[] args){
		List l = new ArrayList();
		l.add(60);
		l.add(90);
		 l.add(60);
		 l.add(70);
		 l.add(56);
		 l.add(45);
	 l.add(45);
		 l.add(45);
		 l.add(45);
		 l.add(34);
		
		l.add(11);
		System.out.println(l);
		 l.add(0, 1);
		
		 System.out.println(l);
		 System.out.println(l.get(3));
		 System.out.println(l.size());
		 System.out.println(l.isEmpty());
		
		 l.set(0, 90);
		 
		 System.out.println(l);
		
		ArrayList l2 = new ArrayList();
		l2.addAll(l);
		System.out.println(l2);
	 
		Object l3 = l2.clone();
		
		System.out.println(l3);
		
		l2.add("Sudhakar");		
		System.out.println(l2);
		
	//	l2.removeAll(l);
		l2.retainAll(l);
		
		System.out.println(l2);
		System.out.println(l);

		Object[] obj = l.toArray();
		System.out.println(obj);
		
		for(Object o : obj){
			System.out.println(o);
		}
	}
}

-------------------------------------------------
LinkedList:-
----------
- LinkedList allows dupliate elements in the list.
- LinkedList preserves order. Store elements in give order. Order is important.
- LinkedList doesn't the implements RandomAccess.
- LinkedList is slower in iteration because it doesn't implement RandomAccess. 
- Algorithm supported by Double ended List
- it is very fast when adding elements.
- LinkedList is not synchronized. It is not thread safe and faster.
- Heterogeneous objects allowed.
- null values are allowed.

Drawback:-
- LinkedList is slower in iteration elements. 

import java.util.*;

public class LinkedListDemo {
	public static void main(String[] args){
		List l = new LinkedList();
		
		l.add(60);
		l.add(90);
		l.add(60);
		l.add(70);
		l.add(56);
		l.add(45);
		l.add(45);
		l.add(45);
		l.add(45);
		l.add(34);
		
		l.add(11);
		System.out.println(l);
		 l.add(0, 1);
		
		 System.out.println(l);
		 System.out.println(l.get(3));
		 System.out.println(l.size());
		 System.out.println(l.isEmpty());
		
		 l.set(0, 90);
		 
		 System.out.println(l);
		
		LinkedList l2 = new LinkedList();
		l2.addAll(l);
		System.out.println(l2);
	 
		Object l3 = l2.clone();
		
		System.out.println(l3);
		
		l2.add("Sudhakar");		
		System.out.println(l2);
		
	//	l2.removeAll(l);
		l2.retainAll(l);
		
		System.out.println(l2);
		System.out.println(l);

		l2.addFirst("Sudhakar");
		l2.addLast("Sudhakar");
		
		Object[] obj = l.toArray();
		l2.removeFirstOccurrence("Sudhakar");
		System.out.println(l2);
		
		for(Object o : obj){
			System.out.println(o);
		}
	}
}

3. Vector:-
----------
- Vector allows dupliate elements in the list.
- Vector preserves order. Store elements in give order. Order is important.
- Vector implements RandomAccess, Cloneable and Serializable
- Vector is faster in iteration because of RandomAccess.
- Algorithm supported by Growable Array
- Default size in Vector is 10
- Vector is index based.
- Vector is sychronized. It is thread safe and it is slower than arraylist when comparing with multiple threads.
- Heterogeneous objects allowed.

Drawback:-
- Vector is slower in adding elements. Internally Vector creates an Array and once it is filled, it will create a new arary and copy elements from old array. Because of this reason it is slow.

Vector v = new Vector();
Vector v = new Vector(collection);
Vector v = new Vector(int capacity);
Vector v = new Vector(int capacity, int increment);


import java.util.*;

public class VectorDemo {
	public static void main(String[] args){
		List l = new Vector(30);
		 l.add(45);
		 l.add(45);
		 l.add(34);
		
		 System.out.println(l.size());
		 System.out.println(l.isEmpty());
		
		 l.set(0, 90);
		Vector v = (Vector) l;
		v.addElement("Sudhakar");
		v.insertElementAt("Ram", 3);
		
		v.setElementAt(90, 1);
		
		System.out.println(v.capacity());
		System.out.println(v.elementAt(1));
		System.out.println(v);
		
		List subList = v.subList(3, 5);
		System.out.println(subList);
	}
}

4. Stack
--------
- The Stack class represents a last-in-first-out (LIFO) stack of objects. It extends class Vector.


peek(): - returns first element but will not remove it.
pop(): - returns first element but will remove it.
push():- add element at top position

import java.util.*;

public class StackDemo {
	public static void main(String[] args){
		List l = new Stack();
		 l.add(45);
		 l.add(45);
		 l.add(34);
		
		 System.out.println(l.size());
		 System.out.println(l.isEmpty());
		
		 l.set(0, 90);
		Stack v = (Stack) l;
		v.addElement("Sudhakar");
		
		v.push("Push");
		
		System.out.println(v.peek());
		System.out.println(v);
		
	}
} 


2. Set (interface)
-------
- Set not allows duplicates.
- order is not important.
- Duplicate objects are not allowed. If we are trying to insert duplicate object we wont get any compile time error or Run time error, add method simply returns false.


1. HashSet:-
-----------
- HashSet will not allow duplicates.
- insertion order is not preserved.
- null values are allowed. But only once because it is not allowed duplicates.
- Algorithm backed by hashtable.
- Default capacity is 16.
- loadFactor is 0 to 1.
- HashSet is not synchronized. It is not thread safe and faster.
- It is faster in searching the elements.
- Heterogeneous objects allowed.


Constructor:-
	HashSet()
	HashSet(Collection<? extends E> c)
	HashSet(int initialCapacity)
	HashSet(int initialCapacity, float loadFactor)
	
	
--------------------------------------------
import java.util.*;
class HashSetDemo{
	public static void main(String[] args){

		// interview logic to avoid duplicates
		int[] arr = {1,23, 34, 22, 22, 34, 45, 56, 34};
		HashSet h = new HashSet();
		for(int a : arr){
			h.add(a);
		}
		
		List li = new ArrayList();
		li.add(1);
		li.add(12);
		li.add(1);
		li.add(1);
		li.add(1);
		li.add(1);
		li.add(null);
		li.add(null);
		li.add(null);
		System.out.println(li);
		
		
		// h.add(34);
		// h.add(35);
		// h.add(37);
		// h.add(34);
		// h.add(35);
		// h.add(null);
		// h.add(null);
		// h.add(null);
		
		System.out.println(h);
		
	}
}
---------------------------------------------------

2. LinkedHashSet:-
- LinkedHashSet is child of HashSet.
- LinkedHashSet will not allow duplicates.
- insertion order is preserved.
- null values are allowed. But only once because it is not allowed dupliates.
- Algorithm backed by hashtable and linked list.
- LinkedHashSet is not synchronized. It is not thread safe and faster.
- Heterogeneous objects allowed.

Note:- For implementing caching application the best suitable Data structure is LinkedHashSet and
LinkedHashMap where duplicate objects are not allowed and insertion order Must be preserved

import java.util.*;
class LinkedHashSetDemo{
	public static void main(String[] args){

		// interview logic to avoid duplicates
		int[] arr = {1,23, 34, 22, 22, 34, 45, 56, 34};
		Set h = new LinkedHashSet();
		for(int a : arr){
			h.add(a);
		}
		
		List li = new ArrayList();
		li.add(1);
		li.add(12);
		li.add(1);
		li.add(1);
		li.add(1);
		li.add(1);
		li.add(null);
		li.add(null);
		li.add(null);
		System.out.println(li);
		
		
		h.add(34);
		h.add(35);
		h.add(37);
		h.add(34);
		h.add(35);
		h.add(null);
		h.add(null);
		h.add(null);
			
		System.out.println(h);
		
	}
}

------------------------------------------------
3. TreeSet
- The underlying Data structure for the TreeSet is Balanced tree.
- Duplicate objects are not allowed. If we are trying to insert duplicate object we wont get any compile time error or Run time error, add method simply returns false.
- Insertion order is not preserved but all the elements are inserted according to some sorting order.
- Heterogeneous objects are not allowed, violation leads to Run time error saying class cast Exception.
- null is not allowed. if we are trying to add null then NullPointerException will occur.

- We can add any elements only which are comparable (Child of comparable objects)
- String, All wrapper classes Integer, Byte, Short .. are implemented Comparable interface.

- If we are trying add any elements which are not comparable then below exception will occur. StringBuffer and StringBuilder are not comparable.
- Exception in thread "main" java.lang.ClassCastException: java.lang.Object cannot be cast to java.lang.Comparable


	Collection
	  | 
	 Set (i)
      | 
	SortedSet (i)
	  |
	NavigableSet (i)
	  |
	TreeSet (c)
	
Constructor:-
TreeSet()
TreeSet(Collection<? extends E> c)
TreeSet(Comparator<? super E> comparator)
TreeSet(SortedSet<E> s)

import java.util.*;
class TreeSetDemo{
	public static void main(String[] args){

		TreeSet t = new TreeSet();
		t.add("Anand");
		t.add("Sudha");
		t.add("Murali");
		t.add("Prasad");
		t.add("Prasad");
		
		//t.add(12); ClassCastException
		//t.add(null); //NullPointerException
		System.out.println(t);
		
		int[] arr = {23, 2, 34, 56, 677, 86, 23, 2};
		System.out.println(Arrays.toString(arr));		
		Arrays.sort(arr);
		System.out.println(Arrays.toString(arr));
		System.out.println(arr[0]);
		System.out.println(arr[arr.length-1]);
		
		Set t1 = new HashSet();
		int count = 0;
		for(int a : arr){
			boolean isAdded = t1.add(a);
			
			if(isAdded == false){
				System.out.println("Duplicte "+ a);
				count = count + 1;
			}
		}
		
		System.out.println(t1);
		System.out.println("Duplicate count:" + count);
		
		
		
	}
}
---------------------------------------------
4. EnumSet:
- A specialized Set implementation for use with enum types.
- duplicate are not allowed.
- heterogenious objects are not allowed.
- It is not a thread safe.

---------------------------------------------------------------------------
07-02-19
Queue: (interface)
-----
- First in First Out order (FIFO)
- duplicate allow
- not thread safe.

						Queue
						  |
				-------- ------------------------- ---------------
				|					| 					| 
				BlockingQueue	BlockingDeque			Deque (interface)
				|					|
				ArrayBlockingQueue	ArrayBlockingDeque	ArrayDeque
		
1. ArrayBlockingQueue

2. PriorityBlockingQueue

3. ArrayDeque

------------------------------------------
1. ArrayBlockingQueue: class
- fifo order 
- it is fixed in size. so dynamically if user adds any elements greater size, it throws exception.
- duplicate are allowed.
- heterogenious objects are allowed.
- Backed algorithms by arraylist.
- iteration is faster.
- null is not allowed.


ArrayBlockingQueue(int capacity)
ArrayBlockingQueue(int capacity, boolean fair)
 
import java.util.concurrent.*;
class ArrayBlockingQueueDemo {
	public static void main(String[] args){
		ArrayBlockingQueue ab = new ArrayBlockingQueue(100);
		ab.add("Sudha");
		ab.add("Sudhakar");
		ab.add(2);
		ab.add(23);
		//ab.add(null);
		
		System.out.println(ab.peek());
		System.out.println(ab);
		
		System.out.println(ab.poll());
		System.out.println(ab.poll());
		System.out.println(ab);
		
	}
 }


2. PriorityBlockingQueue
------------------------
- It doesn't follow fifo order. Order is based prorioty. It follows natural sorting order.
- it is fixed in size. so dynamically if user adds any elements greater size, it throws exception.
- duplicate are allowed.
- heterogenious objects are allowed.
- Backed algorithms by arraylist.
- iteration is faster.
- null is not allowed.

import java.util.concurrent.*;
class PriorityBlockingQueueDemo {
	public static void main(String[] args){
		PriorityBlockingQueue ab = new PriorityBlockingQueue(100);
		ab.add("Sudha");
		ab.add("Sudhakar");
		ab.add("MLA");
		ab.add("CM");
		ab.add("A");
		//ab.add(null);
		
		System.out.println(ab.peek());
		System.out.println(ab);
		
		System.out.println(ab.poll());
		System.out.println(ab.poll());
		System.out.println(ab);
		
	}
 }

3. ArrayDeque
-------------
- It follows FIFO order.
- It is not in fixed size.
- we can add elements at both sides.

- addFirst()
- addLast()
- peekFirst()
- peekLast()

import java.util.*;
class ArrayDequeDemo {
	public static void main(String[] args){
		ArrayDeque ab = new ArrayDeque(100);
		ab.add("Sudha");
		ab.add("Sudhakar");
		ab.add("MLA");
		ab.add("CM");
		ab.addFirst("A");
		//ab.add(null);
		
		System.out.println(ab.peekFirst());
		System.out.println(ab);
		
		System.out.println(ab.pollLast());
		System.out.println(ab);
		
	}
 }
 
ArrayBlockingDeque:-
-----------------
- Size is fixed.
- It follows FIFO order.
- we can add elements at both sides.
 
------------------------------------------------------------------------
09-02-19
Enumeration:
- The first cursor availabe in collections.
- elements() availabe in vector class. Stack also can call this method.
- we can iterator collection elements.
- It is a legacy class 
- One directional cursor 

Object creation:
	Vector v = new Vector();
	Enumeration e = v.elements();
	
	
methods:
hasMoreElements()
nextElement()

drawbacks:-
- we can't remove any elements.
- we can't add any elements.
- we can't iterator previous elements.
- we can't replace any elements.


import java.util.*;
class EnumenrationDemo {
	public static void main(String[] args){
		Vector ab = new Vector(100);
		ab.add("Sudha");
		ab.add("MLA");
		ab.add("CM");
		
		System.out.println("Before:" + ab);		
		Enumeration li = ab.elements();
		
		while(li.hasMoreElements()){
			
			Object o = li.nextElement();
			System.out.println(o);
		}

		System.out.println("After:" + ab);
		
	}
 }

----------------------------------------------------------


Iterator (interface)
--------
- An iterator over a collection. 
- iterator() method is available in Collection. List, Set and Queue can be used this method.
- Universal cursor.
- One directional cursor forward direction.

Object creation:
	Arraylist a = new Arraylist();
	Iterator it = a.iterator();

Method names have been improved.
	hasNext()
	next()
	remove()	- java 8

Drawbacks:
- we can't add any elements.
- we can't iterator previous elements.
- we can't replace any elements.
	
- While iterating the elements using the for each loop if we are adding/deleting then ConcurrentModificationException occurs.
		for(Object o : ab){	//only fo reading purpose
			if("Sudha".equals(o)){
			//	ab.remove(o);
			}
			
			ab.add(null);
			System.out.println(o);
		}

import java.util.*;
class IteratorDemo {
	public static void main(String[] args){
		ArrayList ab = new ArrayList(100);
		ab.add("Sudha");
		ab.add("MLA");
		ab.add("CM");
		//ab.add(null);

		// for(Object o : ab){	//only fo reading purpose
			// if("Sudha".equals(o)){
			// //	ab.remove(o);
			// }
			
			// //ab.add(null);
			// System.out.println(o);
		// }
		
		
		System.out.println("Before delete:" + ab);		
		Iterator it = ab.iterator();
		
		boolean b = it.hasNext();
		System.out.println(b);
		
		while(it.hasNext()){
			Object o = it.next();
			if("Sudha".equals(o)){
				it.remove();
			}			
		}
	

		System.out.println("After delete:" + ab);
		
	}
 }		
-------------------------------------------------------------------
ListIterator: interface
------------
- ListIterator extends Iterator interface
- we can add or remove any elements.
- we iterator next or previous elements.
- we replace any elements.
- listIterator method is availabe in List interface. Only ArrayList, LinkedList, Vector and Stack can use this method.
-  it is bidirectional cursor.

Create object:-
	ListIterator li = al.listIterator();

metods:
------
hasNext
hasPrevious
next
previous
remove
add
set

	import java.util.*;
class ListIteratorDemo {
	public static void main(String[] args){
		ArrayList ab = new ArrayList(100);
		ab.add("Sudha");
		ab.add("MLA");
		ab.add("CM");
		
		System.out.println("Before delete:" + ab);		
		ListIterator li = ab.listIterator();
		
		while(li.hasNext()){
			
			Object o = li.next();
			if("Sudha".equals(o)){
				li.set("Sudhakar");
			}

			if("CM".equals(o)){
				li.add("Chandrababu");
			}
				
			if("MLA".equals(o)){
				li.remove();
			}
			
		}

		System.out.println("After delete:" + ab);
		
	}
 }
----------------------------------------------------------
09-02-19
Comparable (interface)
----------
- It is availabe in java.lang package.
- compareTo(T o) only method is available. return type is int.
- To acheive natural sorting order in TreeSet and PriorityBlockingQueue.
- Already implemented classes are String, Byte, Short, Integer, Long, Float, Double, Character and Boolean.

Comparable implementation should be as shown below:
object1 and object2
return 0: If both are equal
return 1: If object1 is greater than object 2
return -1: If Object1 is lessthan object 2

import java.util.*;

public class ComparableDemo {

	public static void main(String s[]){
		Student s1 = new Student(5, "Sudha");
		Student s2 = new Student(2, "Ram");
		Student s3 = new Student(7, "Midhun");
		Student s4 = new Student(10, "Brand");
		Student s5 = new Student(1, "Karthik");
		
		List list = new ArrayList();
		list.add(s1);
		list.add(s2);
		list.add(s3);
		list.add(s4);
		list.add(s5);
		
		int r1 = s1.compareTo(s2);
		System.out.println(r1);
		
		int r2 = s1.compareTo(s4);
		System.out.println(r2);
		
		int r3 = s1.compareTo(new Student(5, "Ab"));
		System.out.println(r3);
		
		
		TreeSet ts = new TreeSet(list);
		System.out.println(ts);
	}
}

class Student implements Comparable{
	int rollNo;
	String name;
	
	Student(int rollNo, String name){
		this.rollNo = rollNo;
		this.name = name;
	}
	
	public String toString(){
		return "rollNo:"+ rollNo + " name:"+ name;
	}
	
	// public int compareTo(Object o){
		// Student s1 = (Student) o;
		// int rollNo1 = s1.rollNo;
		// //return Integer.valueOf(rollNo).compareTo(s.rollNo);
		
		// int result = 0;
		// if(rollNo == rollNo1){
			// result = 0;
		// }
		// else if(rollNo > rollNo1){
			// result = 1;
		// }
		// else if(rollNo < rollNo1) {
			// result = -1;
		// }
		
		// return result;
	// }
	public int compareTo(Object o){
		Student s1 = (Student) o;
		String name1 = s1.name;
		return name.compareTo(name1);
	}
}

-----------------------------------------------
Comparator
----------
- To achieve the custom sorting order.
- It is availabe in java.util package.
- compare(o1, o2) method and return int value.

For natural sorting order:
object1 and object2
return 0: If both are equal
return 1: If object1 is greater than object 2
return -1: If Object1 is lessthan object 2


For decending sorting order:
object1 and object2
return 0: If both are equal
return -1: If object1 is greater than object 2
return 1: If Object1 is lessthan object 2


import java.util.*;

public class ComparatorDemo {

	public static void main(String s[]){
		StringBuilderComparator sc = new StringBuilderComparator();
		TreeSet ts = new TreeSet(sc);
		ts.add(new StringBuilder("bb"));
		ts.add(new StringBuilder("xb"));
		ts.add(new StringBuilder("Ab"));
		ts.add(1);	//because comparator 
		
		System.out.println(ts);
		
		EmployeeSalaryComparator ec = new EmployeeSalaryComparator();
		EmployeeNameComparator en = new EmployeeNameComparator();
		TreeSet ts2 = new TreeSet(en);
		
		Employee e1 = new Employee("Ab", 200);
		Employee e2 = new Employee("zd", 2000);
		Employee e3 = new Employee("ch", 1000);
		
		ts2.add(e1);
		ts2.add(e2);
		ts2.add(e3);
		
		System.out.println(ts2);
	}
}

class StringBuilderComparator implements Comparator {

	public int compare(Object o1, Object o2){
		String s1 = o1.toString();
		String s2 = o2.toString();
		
		return s1.compareTo(s2); //normal order
		// return s2.compareTo(s1); //reverse order
	}
}

class EmployeeSalaryComparator implements Comparator {

	public int compare(Object o1, Object o2){
		Employee e1 = (Employee) o1;
		Employee e2 = (Employee) o2;
		
		int salary1 = e1.salary;
		int salary2 = e2.salary;
		
		if(salary1 == salary2){
			return 0;
		} else if(salary1 > salary2){
			return 1;
		}else {
			return -1;
		}
	}
}

class EmployeeNameComparator implements Comparator {

	public int compare(Object o1, Object o2){
		Employee e1 = (Employee) o1;
		Employee e2 = (Employee) o2;
		
		return e1.name.compareTo(e2.name);
	}
}

class Employee {
	String name;
	int salary;
	
	Employee(String name, int salary){
		this.name = name;
		this.salary = salary;
	}
	
	public String toString(){
		return "name="+name + " salary="+salary;
	}
}

Drawbacks:
- we can't store key and value pairs in collection,
- we can't store primitive types.

Map: (interface)
----
- java.util package
- Map supports Key and value pairs.
- We can store group of key and value pair objects to map.
- It is not a child of Collection.
- Heterogenious objects are allowed.


HashMap
LinkedHashMap
TreeMap
Hashtable
Properties
IdentityHashMap

1. HashMap
- We can store group of key and value pair objects to map.
- Heterogenious objects are allowed.
- Insertion order is not preserved.
- Duplicate keys are not allowed.
- Duplicte values are allowed.
- When we try set with same key again, value will be updated and it will no throw any error.
- We can store null as key or value.
- default loadFactor is 0.75
- Backed algorithm by hashtable.
- When we are deleting key then automatically value will be deleted from map.
- When a key is not available in map and if user tries to get value for that then map will return null value.

Constructor:
HashMap()
HashMap(int capacity)
HashMap(int initialCapacity, float loadFactor)
HashMap(Map<? extends K,? extends V> m)

import java.util.*;

class HashMapDemo {
	public static void main(String[] args){
		HashMap map = new HashMap(10);
		
		map.put("Telugu", 70);
		map.put("English", 80);
		map.put("Math", 70);
		map.put("Sci", 60);
		map.put("Social", 90);
		map.put("Social", 95);
		map.put("a", null);
		map.put(null, null);
		map.putIfAbsent(null, 1); 
		
		
		HashMap map1 = new HashMap(map);
		
		map1.remove(null);
		map1.put("a", 50);
		
		boolean isExist = map1.containsKey("a");
		System.out.println(isExist);
		
		boolean valueExist = map1.containsValue(150);
		System.out.println(valueExist);
		
		Object value = map1.get("Telugu");
		System.out.println("Telugu " +value);
		
		Object value1 = map1.get("Phy");
		System.out.println("Phy " + value1);		

		value1 = map1.getOrDefault("Phy", 35);
		System.out.println("Default Phy " + value1);
		
		Collection c = map1.values();
		
		Set set = map1.keySet();
		Iterator i = set.iterator();
		
		while(i.hasNext()){
			String subject = (String)i.next();
			Object subjectValue = map1.get(subject);
			System.out.println("Subject: "+ subject + " value:"+ subjectValue);
		}
		
		
		System.out.println(c);
		System.out.println(set);
		
		System.out.println(map);
		System.out.println(map1);
	}
}


2. LinkedHashMap:
- It is a child of HashMap
- We can store group of key and value pair objects to map.
- Heterogenious objects are allowed.
- Insertion order is preserved.
- Duplicate keys are not allowed.
- Duplicte values are allowed.
- When we try set with same key again, value will be updated and it will no throw any error.
- We can store null as key or value.
- default loadFactor is 0.75
- Backed algorithm by hashtable.
- When we are deleting key then automatically value will be deleted from map.
- When a key is not available in map and if user tries to get value for that then map will return null value.

import java.util.*;

class LinkedHashMapDemo {
	public static void main(String[] args){
		HashMap map = new LinkedHashMap(10);
		
		map.put("Telugu", 70);
		map.put("English", 80);
		map.put("Math", 70);
		map.put("Sci", 60);
		map.put("Social", 90);
		map.put("Social", 95);
		map.put("a", null);
		map.put(null, null);
		map.putIfAbsent(null, 1); 
		
		
		HashMap map1 = new LinkedHashMap(map);
		
		map1.remove(null);
		map1.put("a", 50);
		
		boolean isExist = map1.containsKey("a");
		System.out.println(isExist);
		
		boolean valueExist = map1.containsValue(150);
		System.out.println(valueExist);
		
		Object value = map1.get("Telugu");
		System.out.println("Telugu " +value);
		
		Object value1 = map1.get("Phy");
		System.out.println("Phy " + value1);		

		value1 = map1.getOrDefault("Phy", 35);
		System.out.println("Default Phy " + value1);
		
		Collection c = map1.values();
		
		Set set = map1.keySet();
		Iterator i = set.iterator();
		
		while(i.hasNext()){
			String subject = (String)i.next();
			Object subjectValue = map1.get(subject);
			System.out.println("Subject: "+ subject + " value:"+ subjectValue);
		}
		
		
		System.out.println(c);
		System.out.println(set);
		
		System.out.println(map);
		System.out.println(map1);
	}
}
-----------------------------------------------------------------
3. TreeMap
- We can store group of key and value pair objects to map.
- Heterogenious objects are not allowed when TreeMap follows natual sorting order.
- Heterogenious objects are allowed only when TreeMap uses custom comparator.
- Insertion order is not preserved. Byfault it follows natural sorting order bydefault.
- Duplicate keys are not allowed.
- Duplicte values are allowed.
- When we try set with same key again, value will be updated and it will no throw any error.
- We can store null as value only.
- Backed algorithm by Balanced tree.
- When we are deleting key then automatically value will be deleted from map.
- When a key is not available in map and if user tries to get value for that then map will return null value.
- All keys has be Comparable.

import java.util.*;

class TreeMapDemo {
	public static void main(String[] args){
		StringComparator scm = new StringComparator();
		Comparator normal = String.CASE_INSENSITIVE_ORDER;
		Comparator reversed = String.CASE_INSENSITIVE_ORDER.reversed();
		TreeMap map = new TreeMap(normal);
		
		map.put("Telugu", 70);
		map.put("English", 80);
		map.put("math", 70);
		map.put("Sci", 60);
		map.put("Social", 90);
		map.put("Social", 95);
		map.put("a", null);
		// map.put(null, null);
		// map.putIfAbsent(null, 1); 
		
		
		TreeMap map1 = new TreeMap(map);

		map1.put("a", 50);
		
		boolean isExist = map1.containsKey("a");
		System.out.println(isExist);
		
		boolean valueExist = map1.containsValue(150);
		System.out.println(valueExist);
		
		Object value = map1.get("Telugu");
		System.out.println("Telugu " +value);
		
		Object value1 = map1.get("Phy");
		System.out.println("Phy " + value1);		

		value1 = map1.getOrDefault("Phy", 35);
		System.out.println("Default Phy " + value1);
		
		Collection c = map1.values();
		
		Set set = map1.keySet();
		Iterator i = set.iterator();
		
		while(i.hasNext()){
			String subject = (String)i.next();
			Object subjectValue = map1.get(subject);
			System.out.println("Subject: "+ subject + " value:"+ subjectValue);
		}
		
		
		System.out.println(c);
		System.out.println(set);
		
		System.out.println(map);
		System.out.println(map1);
	}
}

class StringComparator implements Comparator {
	public int compare(Object o1, Object o2){
		String s1 = o1.toString();
		String s2 = o2.toString();
		
		return s1.compareToIgnoreCase(s2);
	}
}


-----------------------------------


4. Hashtable:
- We can store group of key and value pair objects to map.
- Heterogenious objects are not allowed.
- Insertion order is not preserved.
- Duplicate keys are not allowed.
- Duplicte values are allowed.
- When we try set with same key again, value will be updated and it will no throw any error.
- null values are not allowed for key and values also.
- Backed algorithm by hash algorithm.
- When we are deleting key then automatically value will be deleted from map.
- When a key is not available in map and if user tries to get value for that then map will return null value.
- Default loadfactor is 0.75
- Hashtable is sychronized. It is thread safe. It is slow when comparing with HashMap.
- If a thread-safe implementation is not needed, it is recommended to use HashMap in place of Hashtable.



import java.util.*;

class HashtableDemo {
	public static void main(String[] args){
		Hashtable map = new Hashtable();
		
		map.put("Telugu", 70);
		map.put("English", 80);
		map.put("math", 70);
		map.put("Sci", 60);
		map.put("Social", 90);
		map.put("Social", 95);
		// map.put(50, 95);
		// map.put("a", null);		
		
		Hashtable map1 = new Hashtable(map);

		map1.put("a", 50);
		
		boolean isExist = map1.containsKey("a");
		System.out.println(isExist);
		
		boolean valueExist = map1.containsValue(150);
		System.out.println(valueExist);
		
		Object value = map1.get("Telugu");
		System.out.println("Telugu " +value);
		
		Object value1 = map1.get("Phy");
		System.out.println("Phy " + value1);		

		value1 = map1.getOrDefault("Phy", 35);
		System.out.println("Default Phy " + value1);
		
		Collection c = map1.values();
		
		Set set = map1.keySet();
		Iterator i = set.iterator();
		
		while(i.hasNext()){
			String subject = (String)i.next();
			Object subjectValue = map1.get(subject);
			System.out.println("Subject: "+ subject + " value:"+ subjectValue);
		}
		
		
		System.out.println(c);
		System.out.println(set);
		
		System.out.println(map);
		System.out.println(map1);
	}
}


Properties:
----------
- To avoid the hardcoding from java file.
- Properties class is used for storing key and value pairs.
- It is extended Hastable.
- we can modify and key and value pairs and  no need to recompile the program.



Steps for reading:-
1. object create for propeties
2. read the properties file using file reader.
3. load reader to properties.
4. Get property from properties


Constructor:
Properties()
Properties(Properties p)

methods:-
load(Reader r)
load(InputStream is)

//To store values to properties file.
store(OutputStream out, String comments)
store(Writer writer, String comments)

getProperty(String key)
getProperty(String key, String defaultValue)	




import java.util.*;
import java.io.*;

class PropertiesDemo{
    public static void main(String...q) {
		 String user = "Suda";
		 
		 //1. object create for propeties
		 Properties p = new Properties();
		 
		
		 
		try{
			//read the properties file
			Reader r = new FileReader("sample.properties");
		 
			//load reader to properties.
			p.load(r);
		}catch(IOException e){}
	
		 p.setProperty("lenovo", "70000");
		 System.out.println(p);
		 System.out.println(p.getProperty("lenovo", "6000"));
		 
		 //Get property from properties
		 String userFromProp = p.getProperty("username");
		 
		 if("Sudha".equals(userFromProp)){
			System.out.println("Successfully logged in");
		 }else {
			System.out.println("Failed to loggin");
		 }
	}
}

import java.util.*;
import java.io.*;

class PropertiesWritingDemo{
    public static void main(String...q) {
		 String user = "Suda";
		 
		 //1. object create for propeties
		 Properties p = new Properties();
		 
		
		 
		try{
			//read the properties file
			Reader r = new FileReader("sample.properties");
		 
			//load reader to properties.
			p.load(r);
		}catch(IOException e){}
	
		 p.setProperty("lenovo", "70000");
		 System.out.println(p);
		 System.out.println(p.getProperty("lenovo", "6000"));
		 
		 String userFromProp = p.getProperty("username");
		 
		 if("Sudha".equals(userFromProp)){
			System.out.println("Successfully logged in");
		 }else {
			System.out.println("Failed to loggin");
		 }
		 
		 
		 try{
		 
		 Writer w = new FileWriter("sample.properties");
		 p.store(w, "store lenovo value");
		 }
		 catch(Exception e){}
		 
	}
}

------------------------------------------------------------------------
Collections:- 
- It is a utility class.

synchronizedList(List<T> list): To get the synchronized list. Thread safe list.
sort(List)
sort(List, Comparator)


Arrays:
- It is utility class

sort()

import java.util.*;

class CollectionsDemo {
	public static void main(String args[]){
		List l = new ArrayList();
		l.add(10);
		l.add(1);
		l.add(25);
		l.add(40);
		
		System.out.println(l);
		
		List synchronizedList = Collections.synchronizedList(l);
		System.out.println(synchronizedList);
		
		Collections.sort(l);
		Collections.sort(l, new NumComparator());
		System.out.println(l);
	}
}

class NumComparator implements Comparator<Integer> {
	public int compare(Integer i1, Integer i2){
		return i2.compareTo(i1);
	}
}
-----------------------------
11-020-2019
Thread
- create thread
- runnable
- life cycle

Multi tasking:
1. Process based

2. Thread based

Process based Multi Tasking
Executing several tasks simultaneously where each task is a separate independent process is
called Process based Multitasking.
Ex:
	While writing java program in the editor we can run MP3 player. At the same time we
	can download a file from the net. All these tasks are executing simultaneously and
	independent of each other. Hence it is process based Multitasking. Process based
	Multitasking is best suitable at O.S level.


Thread based Multi Tasking

Executing several tasks simultaneously where each task is a separate independent part of the
same program is called Thread based Multitasking. This type of multitasking is best suitable
at programmatic level.
Java provides in built support for thread based multitasking by providing rich library (Thread,
ThreadGroup, Runnable ..etc)
Whether it is Processbased or Threadbased the main objective of multitasking is to reduce
response time and improve performance of the system.


important:
Runnable - I
  |
Thread	- C
ThreadGroup - C

How to create Thread?
1. By extending Thread class
2. By implement Runnable interface.


Thread:-
- Direct or indirect child of Runnable called Thread.
- A thread is a thread of execution in a program. The Java Virtual Machine allows an application to have multiple threads of execution running concurrently.

Constructor:

Thread() :Allocates a new Thread object.

Thread(Runnable target): Allocates a new Thread object.

Thread(Runnable target, String name): Allocates a new Thread object.

Thread(String name): Allocates a new Thread object.

Thread(ThreadGroup group, Runnable target)
Allocates a new Thread object.

Thread(ThreadGroup group, Runnable target, String name)
Allocates a new Thread object so that it has target as its run object, has the specified name as its name, and belongs to the 
thread group referred to by group.

Thread(ThreadGroup group, Runnable target, String name, long stackSize)
Allocates a new Thread object so that it has target as its run object, has the specified name as its name, and belongs to the thread group referred to by group, and has the specified stack size.

Thread(ThreadGroup group, String name)
Allocates a new Thread object.

Methods:
run():	Work has be to defined in this method
start(): To start the new thread
static currentThread():	Returns current thread.
getId():	returns id 
getName()	: returns thread name
setName():
getPriority(): Allowed priority is 1-10. Default priority 5
setPriority(int)

interrupt()
isDaemon()
join()
join(long mill)
sleep(long millis)
yield()	
	
	
Steps:-
1. Create a class which extends Thread
	//1 create class
	class HelloThread extends Thread {
		
	}
	
2. Override the run method in newly created class.

	//1 create class
	class HelloThread extends Thread {
		
		//override 
		public void run(){
			System.out.println("Hello thread");
		}
	}

3. Create Object for our thread class
	HelloThread ht = new HelloThread();

4. Invoke start method.
	ht.start();
	
- When ever we call start() method, automatically Thread class will invoke our run() method. No need to call run method directly.	
	
	
- Main thread is start by JVM. by default main thread priorty 5
- By default child thread start by main thread.
- By default all child thread get priority from parent so default priority is 5.
- we can set priority by using setPriority().














IO package:


Java Generics:



